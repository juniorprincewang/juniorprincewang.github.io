<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"juniorprincewang.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="搞安全怎么能离开密码学。武功再高，也怕菜刀。 骐骥一跃，不能十步。">
<meta property="og:type" content="article">
<meta property="og:title" content="密码学EXM?">
<meta property="og:url" content="http://juniorprincewang.github.io/2017/08/06/crypto-docs/index.html">
<meta property="og:site_name" content="TO DO">
<meta property="og:description" content="搞安全怎么能离开密码学。武功再高，也怕菜刀。 骐骥一跃，不能十步。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://juniorprincewang.github.io/img/crypto-docs/exm.jpg">
<meta property="og:image" content="http://juniorprincewang.github.io/2017/08/06/%E5%AF%86%E7%A0%81%E5%AD%A6EXM/Diffie-Hellman-Schl%C3%BCsselaustausch.svg">
<meta property="article:published_time" content="2017-08-06T02:41:42.000Z">
<meta property="article:modified_time" content="2023-07-06T09:37:13.333Z">
<meta property="article:author" content="Max">
<meta property="article:tag" content="cryptography">
<meta property="article:tag" content="国产密码">
<meta property="article:tag" content="ECDSA">
<meta property="article:tag" content="SM">
<meta property="article:tag" content="RSA">
<meta property="article:tag" content="AES">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://juniorprincewang.github.io/img/crypto-docs/exm.jpg">


<link rel="canonical" href="http://juniorprincewang.github.io/2017/08/06/crypto-docs/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://juniorprincewang.github.io/2017/08/06/crypto-docs/","path":"2017/08/06/crypto-docs/","title":"密码学EXM?"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>密码学EXM? | TO DO</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TO DO</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">吾尝终日而思矣，不如须臾之所学也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tutorials"><span class="nav-number">1.</span> <span class="nav-text">tutorials</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%AF%E6%92%92%E5%92%8C%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">凯撒和栅栏密码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#base643216%E7%BC%96%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">base64&#x2F;32&#x2F;16编码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stream-cipher"><span class="nav-number">4.</span> <span class="nav-text">stream cipher</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rc4-arch4"><span class="nav-number">4.1.</span> <span class="nav-text">RC4 (arch4)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#salsa20"><span class="nav-number">4.2.</span> <span class="nav-text">Salsa20</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chacha"><span class="nav-number">4.3.</span> <span class="nav-text">ChaCha</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kdf"><span class="nav-number">5.</span> <span class="nav-text">KDF</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">填充模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F-mode-of-operation"><span class="nav-number">6.1.</span> <span class="nav-text">分组密码工作模式 mode of
operation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E5%AF%86%E7%A0%81%E6%9C%ACelectronic-codebookecb"><span class="nav-number">6.1.1.</span> <span class="nav-text">电子密码本（Electronic
codebook，ECB）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E5%9D%97%E9%93%BE%E6%8E%A5cbccipher-block-chaining"><span class="nav-number">6.1.2.</span> <span class="nav-text">密码块链接（CBC，Cipher-block
chaining）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8Fctrcounter-mode"><span class="nav-number">6.1.3.</span> <span class="nav-text">计数器模式（CTR，Counter Mode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E5%9D%97%E9%93%BE%E6%8E%A5-pcbcpropagating-cipher-block-chaining"><span class="nav-number">6.1.4.</span> <span class="nav-text">填充密码块链接
（PCBC，Propagating cipher-block chaining）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E6%96%87%E5%8F%8D%E9%A6%88cfbcipher-feedback"><span class="nav-number">6.1.5.</span> <span class="nav-text">密文反馈（CFB，Cipher
feedback）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8Foutput-feedback-ofb"><span class="nav-number">6.1.6.</span> <span class="nav-text">输出反馈模式（Output feedback,
OFB）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcm"><span class="nav-number">6.1.7.</span> <span class="nav-text">GCM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#padding"><span class="nav-number">6.2.</span> <span class="nav-text">padding</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pkcs5pkcs7-padding"><span class="nav-number">6.2.1.</span> <span class="nav-text">PKCS#5&#x2F;PKCS#7 padding</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#message-authentication-codemac"><span class="nav-number">6.3.</span> <span class="nav-text">Message Authentication
Code(MAC)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-based-message-authentication-codehmac"><span class="nav-number">6.3.1.</span> <span class="nav-text">Hash-based Message
Authentication Code(HMAC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aeadauthenticated-encryption-with-associated-data"><span class="nav-number">6.3.2.</span> <span class="nav-text">AEAD(Authenticated
Encryption with Associated Data)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#block-ciphers"><span class="nav-number">7.</span> <span class="nav-text">Block ciphers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#aes"><span class="nav-number">7.1.</span> <span class="nav-text">AES</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aes-%E5%8A%A0%E5%AF%86"><span class="nav-number">7.1.1.</span> <span class="nav-text">AES 加密</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#subbytes"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">SubBytes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shiftrows"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">ShiftRows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invshiftrows"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">InvShiftRows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invsubbytes"><span class="nav-number">7.1.1.4.</span> <span class="nav-text">InvSubBytes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invmixcolumns"><span class="nav-number">7.1.1.5.</span> <span class="nav-text">InvMixColumns</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.1.2.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rsa"><span class="nav-number">8.</span> <span class="nav-text">RSA</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rsa%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">8.1.</span> <span class="nav-text">RSA算法流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modular-exponentiation"><span class="nav-number">8.2.</span> <span class="nav-text">Modular Exponentiation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3sliding-windows"><span class="nav-number">8.2.1.</span> <span class="nav-text">滑动窗口：sliding windows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#crt-calculation"><span class="nav-number">8.2.2.</span> <span class="nav-text">CRT calculation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#montgomery-multiplication"><span class="nav-number">8.2.3.</span> <span class="nav-text">Montgomery Multiplication</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#padding-1"><span class="nav-number">8.3.</span> <span class="nav-text">padding</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pkcs1"><span class="nav-number">8.3.1.</span> <span class="nav-text">PKCS1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#oaep"><span class="nav-number">8.3.2.</span> <span class="nav-text">OAEP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pss"><span class="nav-number">8.3.3.</span> <span class="nav-text">PSS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#paillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95paillier-homomorphic-encryption"><span class="nav-number">9.</span> <span class="nav-text">Paillier同态加密算法(Paillier
Homomorphic Encryption)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="nav-number">9.1.</span> <span class="nav-text">密钥生成：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">加密过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="nav-number">9.3.</span> <span class="nav-text">解密过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%81%E6%98%8E"><span class="nav-number">9.4.</span> <span class="nav-text">证明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">9.5.</span> <span class="nav-text">同态的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%80%81%E5%8A%A0%E6%B3%95"><span class="nav-number">9.5.1.</span> <span class="nav-text">同态加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%80%81%E4%B9%98%E6%B3%95"><span class="nav-number">9.5.2.</span> <span class="nav-text">同态乘法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%99%BE%E4%B8%87%E5%AF%8C%E7%BF%81%E5%AE%89%E5%85%A8%E6%AF%94%E5%AF%8C%E9%97%AE%E9%A2%98"><span class="nav-number">9.6.</span> <span class="nav-text">百万富翁安全比富问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E-zero-knowledge-proof"><span class="nav-number">10.</span> <span class="nav-text">零知识证明 Zero-knowledge
proof</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E4%BD%93%E7%B3%BBdiscrete-logarithm"><span class="nav-number">11.</span> <span class="nav-text">离散对数体系（Discrete
Logarithm）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98"><span class="nav-number">11.1.</span> <span class="nav-text">困难问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#d-h"><span class="nav-number">11.2.</span> <span class="nav-text">D-H</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84dh%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2ecdh"><span class="nav-number">11.3.</span> <span class="nav-text">基于椭圆曲线的DH密钥交换（ECDH）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#elgamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">11.4.</span> <span class="nav-text">ElGamal加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90-1"><span class="nav-number">11.4.1.</span> <span class="nav-text">密钥生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86"><span class="nav-number">11.4.2.</span> <span class="nav-text">加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86"><span class="nav-number">11.4.3.</span> <span class="nav-text">解密</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#elgamal%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><span class="nav-number">11.5.</span> <span class="nav-text">ElGamal签名算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90-2"><span class="nav-number">11.5.1.</span> <span class="nav-text">密钥生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D"><span class="nav-number">11.5.2.</span> <span class="nav-text">签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">11.5.3.</span> <span class="nav-text">验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dsa--digital-signature-algorithm"><span class="nav-number">11.6.</span> <span class="nav-text">DSA -Digital Signature
Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90-3"><span class="nav-number">11.6.1.</span> <span class="nav-text">密钥生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D-1"><span class="nav-number">11.6.2.</span> <span class="nav-text">签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81-1"><span class="nav-number">11.6.3.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="nav-number">11.6.4.</span> <span class="nav-text">正确性证明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ecdsa"><span class="nav-number">11.7.</span> <span class="nav-text">ECDSA</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#elliptic-curve-cryptography-ecc"><span class="nav-number">12.</span> <span class="nav-text">Elliptic Curve Cryptography
(ECC)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BD%E4%BA%A7%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">国产密码算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sm2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97"><span class="nav-number">13.1.</span> <span class="nav-text">SM2椭圆曲线公钥密码算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sm2-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><span class="nav-number">13.1.1.</span> <span class="nav-text">SM2-椭圆曲线数字签名算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sm2-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE"><span class="nav-number">13.1.2.</span> <span class="nav-text">SM2-椭圆曲线密钥交换协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sm2-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">13.1.3.</span> <span class="nav-text">SM2-椭圆曲线公钥加密算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sm3%E6%9D%82%E5%87%91%E7%AE%97%E6%B3%95"><span class="nav-number">13.2.</span> <span class="nav-text">SM3杂凑算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A1%AB%E5%85%85"><span class="nav-number">13.2.1.</span> <span class="nav-text">消息填充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%8E%8B%E7%BC%A9"><span class="nav-number">13.2.2.</span> <span class="nav-text">迭代压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sm4%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95"><span class="nav-number">13.3.</span> <span class="nav-text">SM4分组密码算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95"><span class="nav-number">13.3.1.</span> <span class="nav-text">密钥扩展算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">13.3.2.</span> <span class="nav-text">加密算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">13.3.3.</span> <span class="nav-text">解密算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A5%96%E5%86%B2%E4%B9%8B%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95"><span class="nav-number">13.4.</span> <span class="nav-text">祖冲之序列密码算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">14.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Max</p>
  <div class="site-description" itemprop="description">文章本天成，妙手偶得之。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/juniorprincewang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;juniorprincewang" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:maxzywang@163.com" title="E-Mail → mailto:maxzywang@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://juniorprincewang.github.io/2017/08/06/crypto-docs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TO DO">
      <meta itemprop="description" content="文章本天成，妙手偶得之。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="密码学EXM? | TO DO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          密码学EXM?
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-06 10:41:42" itemprop="dateCreated datePublished" datetime="2017-08-06T10:41:42+08:00">2017-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-06 17:37:13" itemprop="dateModified" datetime="2023-07-06T17:37:13+08:00">2023-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/security/" itemprop="url" rel="index"><span itemprop="name">security</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/security/crypto/" itemprop="url" rel="index"><span itemprop="name">crypto</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>搞安全怎么能离开密码学。武功再高，也怕菜刀。<br />
骐骥一跃，不能十步。 <span id="more"></span></p>
<p><img src="/img/crypto-docs/exm.jpg" /></p>
<h1 id="tutorials">tutorials</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://cryptobook.nakov.com/">Practical Cryptography for
Developers</a><br />
本书算是实用密码学实战，以python开发，涉及了 <strong>hashes</strong>
(like SHA-3 and BLAKE2), <strong>MAC codes</strong> (like HMAC and
GMAC), <strong>key derivation functions</strong> (like Scrypt, Argon2),
<strong>key agreement protocols</strong> (like DHKE, ECDH),
<strong>symmetric ciphers</strong> (like AES and ChaCha20, cipher block
modes, authenticated encryption, AEAD, AES-GCM, ChaCha20-Poly1305),
<strong>asymmetric ciphers and public-key cryptosystems</strong> (RSA,
ECC, ECIES), <strong>elliptic curve cryptography</strong> (ECC,
secp256k1, curve25519), <strong>digital signatures</strong> (ECDSA and
EdDSA), <strong>secure random numbers</strong> (PRNG, CSRNG) and
<strong>quantum-safe cryptography</strong> 。</li>
</ul>
<h1 id="凯撒和栅栏密码">凯撒和栅栏密码</h1>
<p><code>Cipher Block</code> ： 分组密码 <code>nonce</code> : <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cryptographic_nonce">Nonce</a>
是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。<br />
Nonce也用于 <em>流密码</em>
以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。</p>
<h1 id="base643216编码">base64/32/16编码</h1>
<p>原来仅仅听过base64，后来还听到了base32,
base16。其实原理都一样，base64、base32、base16可以分别编码转化8位字节为6位、5位、4位。这里重点介绍base64。
Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括MIME的email，email
via MIME,在XML中存储复杂数据。</p>
<p>编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表。</p>
<p>python的base64模块用于base64/32/16编码和解码。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">s=&quot;test&quot;</span><br><span class="line">t = base64.b64encode(s)</span><br><span class="line">print t</span><br><span class="line">print base64.b64decode(t)</span><br></pre></td></tr></table></figure></p>
<h1 id="stream-cipher">stream cipher</h1>
<h2 id="rc4-arch4">RC4 (arch4)</h2>
<p>不安全的流密码算法，已经被TLS弃用。 <a
target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7465">rfc7465 Prohibiting RC4
Cipher Suites</a></p>
<h2 id="salsa20">Salsa20</h2>
<p>一种新的流加密算法，由 Dan Bernstein 设计。根据内部轮数分为
Salsa20/12 和 Salsa20/8 。 基于 add-rotate-xor（ARX）操作。</p>
<p>优势：</p>
<p>用户可以在恒定时间内寻求输出流中的任何位置。它可以在现代x86处理器中提供约每4–14次循环周期一字节的速度，并具有合理的硬件性能。可以抵御侧信道攻击。</p>
<h2 id="chacha">ChaCha</h2>
<p>也是由Dan Bernstein 设计的新型的流加密算法。
根据轮数不同分为：ChaCha8,ChaCha12,ChaCha20。</p>
<p><a target="_blank" rel="noopener" href="https://cr.yp.to/snuffle.html">Snuffle 2005: the Salsa20
encryption function</a></p>
<h1 id="kdf">KDF</h1>
<h1 id="填充模式">填充模式</h1>
<h2 id="分组密码工作模式-mode-of-operation">分组密码工作模式 mode of
operation</h2>
<p>分组（block）密码的工作模式（mode of
operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。
常用模式有以下几块：</p>
<h3 id="电子密码本electronic-codebookecb">电子密码本（Electronic
codebook，ECB）</h3>
<p>讲消息分成组，每组单独加密。</p>
<p><strong>缺点</strong></p>
<ul>
<li>Visual inspection of an encrypted stream</li>
</ul>
<p>本方法的缺点在于同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。
+ Encryption oracle attack<br />
加密预言攻击，oracle是用于计算用的黑盒子，称为“预言机”。 比如对于
<code>C = ECB(k, m|S)</code> ，敌手就可以选择m长度为 len(block)-1
大小，那么整个块为
m|s0，敌手可以遍历最终匹配到s0，以此类推获得整个密文对应的明文。</p>
<h3
id="密码块链接cbccipher-block-chaining">密码块链接（CBC，Cipher-block
chaining）</h3>
<h3 id="计数器模式ctrcounter-mode">计数器模式（CTR，Counter Mode）</h3>
<h3
id="填充密码块链接-pcbcpropagating-cipher-block-chaining">填充密码块链接
（PCBC，Propagating cipher-block chaining）</h3>
<p>填充密码块链接 （PCBC，Propagating cipher-block
chaining）或称为明文密码块链接（Plaintext cipher-block chaining）。</p>
<h3 id="密文反馈cfbcipher-feedback">密文反馈（CFB，Cipher
feedback）</h3>
<h3 id="输出反馈模式output-feedback-ofb">输出反馈模式（Output feedback,
OFB）</h3>
<h3 id="gcm">GCM</h3>
<p><a
target="_blank" rel="noopener" href="https://csrc.nist.gov/publications/detail/sp/800-38d/final">SP
800-38D:Recommendation for Block Cipher Modes of Operation:
Galois/Counter Mode (GCM) and GMAC</a></p>
<h2 id="padding">padding</h2>
<h3 id="pkcs5pkcs7-padding">PKCS#5/PKCS#7 padding</h3>
<p>PKCS是 Public Key Cryptography Standards 的简称。</p>
<p>PKCS#5 是基于口令的加密标准，目前版本是 2.1。<br />
它将输入按照BlockSize=8字节进行分组，最后一组要填充成8字节。
加入口令长度为 <span class="math inline">\(x\)</span>，则填充数据是
<span class="math inline">\(8-(x%8)\)</span>，每个padding的字节值是
<span
class="math inline">\(8-(x%8)\)</span>；若口令长度恰好为8的整数倍，仍需要在后面增添一组，每个元素为0x08。</p>
<p>这么做的目的：在解密时，根据密文的最后一位来确定填充字节数。因此如果原明文是8的整数倍，仍在末尾填充一组。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8018">rfc8018 - PKCS #5:
Password-Based Cryptography Specification Version 2.1</a></p>
<h2 id="message-authentication-codemac">Message Authentication
Code(MAC)</h2>
<h3 id="hash-based-message-authentication-codehmac">Hash-based Message
Authentication Code(HMAC)</h3>
<p><a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc4418.txt">rfc4418 UMAC: Message
Authentication Code using Universal Hashing</a></p>
<h3
id="aeadauthenticated-encryption-with-associated-data">AEAD(Authenticated
Encryption with Associated Data)</h3>
<h1 id="block-ciphers">Block ciphers</h1>
<p>分组密码算法</p>
<h2 id="aes">AES</h2>
<p>AES作为DES的升级版本，是当今主流的对称加密算法。
AES选取的分组长度为128比特，保持不变，而密钥长度可改变为128比特、192比特和256比特。
AES包括加解密(encrypt/decrypt)和轮密钥生成(key shedule)。
加解密涉及四个操作：SubBytes(字节替换)、ShiftRows(行移位)、MixColumns(列混淆)、AddRoundKey(轮密钥加)。在最后一轮不进行MixColumns。</p>
<p>可以参考 <a
target="_blank" rel="noopener" href="https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf">FIPS
197，AES</a>。里面有详实的标准介绍。</p>
<h3 id="aes-加密">AES 加密</h3>
<p>加密算法流程为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])</span><br><span class="line">begin</span><br><span class="line">	byte state[4,Nb]</span><br><span class="line">	state = in</span><br><span class="line">	AddRoundKey(state, w[0, Nb-1]) // See Sec. 5.1.4</span><br><span class="line">	for round = 1 step 1 to Nr–1</span><br><span class="line">		SubBytes(state) // See Sec. 5.1.1</span><br><span class="line">		ShiftRows(state) // See Sec. 5.1.2</span><br><span class="line">		MixColumns(state) // See Sec. 5.1.3</span><br><span class="line">		AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])</span><br><span class="line">	end for</span><br><span class="line">	SubBytes(state)</span><br><span class="line">	ShiftRows(state)</span><br><span class="line">	AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])</span><br><span class="line">	out = state</span><br><span class="line">end</span><br></pre></td></tr></table></figure> + <code>State</code>
一个4行的矩阵，每行包括Nb个字节。用于行移位和列混淆。 + <code>Nb</code>
组成 <code>State</code> 的列（一列4个字节，共32位）数量。这里取4。 +
<code>Nk</code>
表示密钥长度，32位字节的数量。对于128，192，256长度的密钥来说，Nk分别取4,
6, 8。 + <code>Nr</code>
轮数量，对于128，192，256长度的密钥来说，Nr分别取10, 12, 14。</p>
<table>
<thead>
<tr class="header">
<th>密钥算法</th>
<th>密钥长度Nk字节</th>
<th>分组长度Nb字节</th>
<th>轮数Nr</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AES-128</td>
<td>4</td>
<td>4</td>
<td>10</td>
</tr>
<tr class="even">
<td>AES-192</td>
<td>6</td>
<td>4</td>
<td>12</td>
</tr>
<tr class="odd">
<td>AES-256</td>
<td>8</td>
<td>4</td>
<td>14</td>
</tr>
</tbody>
</table>
<h4 id="subbytes">SubBytes</h4>
<p>SubBytes，将原 State中的每个字符转换成S-Box中对应下标的元素。 即
<code>State[i,j] = s_box[State[i,j]]</code> 。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint8_t s_box[256] = &#123;</span><br><span class="line">	// 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f</span><br><span class="line">	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, // 0</span><br><span class="line">	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, // 1</span><br><span class="line">	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, // 2</span><br><span class="line">	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, // 3</span><br><span class="line">	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, // 4</span><br><span class="line">	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, // 5</span><br><span class="line">	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, // 6</span><br><span class="line">	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, // 7</span><br><span class="line">	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, // 8</span><br><span class="line">	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, // 9</span><br><span class="line">	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, // a</span><br><span class="line">	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, // b</span><br><span class="line">	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, // c</span><br><span class="line">	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, // d</span><br><span class="line">	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, // e</span><br><span class="line">	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16&#125;;// f</span><br></pre></td></tr></table></figure></p>
<h4 id="shiftrows">ShiftRows</h4>
<p>ShiftRows，将State数组按照行 依次向左移位0字节，1字节，2字节，3字节。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Row0: s0  s4  s8  s12   &lt;&lt;&lt; 0 byte</span><br><span class="line">Row1: s1  s5  s9  s13   &lt;&lt;&lt; 1 byte</span><br><span class="line">Row2: s2  s6  s10 s14   &lt;&lt;&lt; 2 bytes</span><br><span class="line">Row3: s3  s7  s11 s15   &lt;&lt;&lt; 3 bytes</span><br></pre></td></tr></table></figure> #### MixColumns</p>
<p>MixColumns:
利用GF(2^8)域上算术特性的一个代替，同样用于提供算法的扩散性。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[02 03 01 01]   [s0  s4  s8  s12]</span><br><span class="line">[01 02 03 01] . [s1  s5  s9  s13]</span><br><span class="line">[01 01 02 03]   [s2  s6  s10 s14]</span><br><span class="line">[03 01 01 02]   [s3  s7  s11 s15]</span><br></pre></td></tr></table></figure> 而此处的乘法和加法都是定义在GF(2^8)上的,
将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011。
乘法对加法满足分配率。
这里计算起来比较麻烦。但是如果用查表的话，速度会提升不少。 <a
target="_blank" rel="noopener" href="https://blog.csdn.net/lisonglisonglisong/article/details/41909813">有限域
GF(2^8) 上的乘法改用查表的方式实现</a> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">byte Mul_02[256] = &#123;</span><br><span class="line">	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,</span><br><span class="line">	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,</span><br><span class="line">	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,</span><br><span class="line">	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,</span><br><span class="line">	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,</span><br><span class="line">	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,</span><br><span class="line">	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,</span><br><span class="line">	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,</span><br><span class="line">	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,</span><br><span class="line">	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,</span><br><span class="line">	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,</span><br><span class="line">	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,</span><br><span class="line">	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,</span><br><span class="line">	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,</span><br><span class="line">	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,</span><br><span class="line">	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">byte Mul_03[256] = &#123;</span><br><span class="line">	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,</span><br><span class="line">	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,</span><br><span class="line">	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,</span><br><span class="line">	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,</span><br><span class="line">	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,</span><br><span class="line">	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,</span><br><span class="line">	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,</span><br><span class="line">	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,</span><br><span class="line">	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,</span><br><span class="line">	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,</span><br><span class="line">	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,</span><br><span class="line">	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,</span><br><span class="line">	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,</span><br><span class="line">	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,</span><br><span class="line">	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,</span><br><span class="line">	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ####
AddRoundKey</p>
<p>AddRoundKey, 将State和密钥进行XOR。</p>
<p>轮密钥生成： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)</span><br><span class="line">begin</span><br><span class="line">	word temp</span><br><span class="line">	i = 0</span><br><span class="line">	while (i &lt; Nk)</span><br><span class="line">		w[i] = word(key[4*i], key[4*i+1], key[4*i+2], key[4*i+3])</span><br><span class="line">		i = i+1</span><br><span class="line">	end while</span><br><span class="line">	i = Nk</span><br><span class="line">	while (i &lt; Nb * (Nr+1)]</span><br><span class="line">		temp = w[i-1]</span><br><span class="line">		if (i mod Nk = 0)</span><br><span class="line">			temp = SubWord(RotWord(temp)) xor Rcon[i/Nk]</span><br><span class="line">		else if (Nk &gt; 6 and i mod Nk = 4)</span><br><span class="line">			temp = SubWord(temp)</span><br><span class="line">		end if</span><br><span class="line">		w[i] = w[i-Nk] xor temp</span><br><span class="line">		i = i + 1</span><br><span class="line">	end while</span><br><span class="line">end</span><br></pre></td></tr></table></figure> 1.
将128位种子密钥按照列进行排列，其中<strong>w0</strong>=k0 k1 k2 k3。</p>
<table>
<thead>
<tr class="header">
<th>w0</th>
<th>w1</th>
<th>w2</th>
<th>w3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k0</td>
<td>k4</td>
<td>k8</td>
<td>k12</td>
</tr>
<tr class="even">
<td>k1</td>
<td>k5</td>
<td>k9</td>
<td>k13</td>
</tr>
<tr class="odd">
<td>k2</td>
<td>k6</td>
<td>k10</td>
<td>k14</td>
</tr>
<tr class="even">
<td>k3</td>
<td>k7</td>
<td>k11</td>
<td>k15</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>设j是整数并且j属于[4,
43]，若j%4=0,w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]。
w[j]是前一列w[j-1]与上一轮w[j-Nb]异或的结果，如果是首列j%4==0，那么需要对它前一列w[j-1]做g(w)处理。</li>
<li>函数g(w)的操作为
<ol type="1">
<li>将w循环左移8位。（仅对w循环）</li>
<li>分别对w的4个字节做S盒(S-Box)置换；</li>
<li>与32比特的常量（RC[j/4],0,0,0）进行异或。Rc={0x00, 0x01, 0x02, 0x04,
0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36}</li>
</ol></li>
</ol>
<p>AES加密算法的动态演示 <a
target="_blank" rel="noopener" href="https://coolshell.cn/wp-content/uploads/2010/10/rijndael_ingles2004.swf"
class="uri">https://coolshell.cn/wp-content/uploads/2010/10/rijndael_ingles2004.swf</a>
### AES 解密</p>
<p>解密的话也需要四个步骤：InvShiftRows(逆行移位),
InvSubBytes(逆字节替换),InvMixColumns(逆列混淆),和
AddRoundKey(轮密钥加)。 但是解密的顺序略有不同。 <code>w</code>
为轮密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])</span><br><span class="line">begin</span><br><span class="line">	byte state[4,Nb]</span><br><span class="line">	state = in</span><br><span class="line">	AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1]) // See Sec. 5.1.4</span><br><span class="line">	for round = Nr-1 step -1 downto 1</span><br><span class="line">		InvShiftRows(state) // See Sec. 5.3.1</span><br><span class="line">		InvSubBytes(state) // See Sec. 5.3.2</span><br><span class="line">		AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])</span><br><span class="line">		InvMixColumns(state) // See Sec. 5.3.3</span><br><span class="line">	end for</span><br><span class="line">	InvShiftRows(state)</span><br><span class="line">	InvSubBytes(state)</span><br><span class="line">	AddRoundKey(state, w[0, Nb-1])</span><br><span class="line">	out = state</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="invshiftrows">InvShiftRows</h4>
<p>InvShiftRows 只是将 State序列按照 行号，
进行逆向向右依次移动0个字节、1个字节、2个字节、3个字节。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		state</span><br><span class="line">Row0: s0  s4  s8  s12   &gt;&gt;&gt; 0 byte</span><br><span class="line">Row1: s1  s5  s9  s13   &gt;&gt;&gt; 1 byte</span><br><span class="line">Row2: s2  s6  s10 s14   &gt;&gt;&gt; 2 bytes</span><br><span class="line">Row3: s3  s7  s11 s15   &gt;&gt;&gt; 3 bytes</span><br></pre></td></tr></table></figure></p>
<h4 id="invsubbytes">InvSubBytes</h4>
<p>InvSubBytes 字节替换用到的逆序S-Box为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f</span><br><span class="line">0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, // 0</span><br><span class="line">0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, // 1</span><br><span class="line">0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, // 2</span><br><span class="line">0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, // 3</span><br><span class="line">0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, // 4</span><br><span class="line">0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, // 5</span><br><span class="line">0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, // 6</span><br><span class="line">0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, // 7</span><br><span class="line">0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, // 8</span><br><span class="line">0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, // 9</span><br><span class="line">0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, // a</span><br><span class="line">0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, // b</span><br><span class="line">0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, // c</span><br><span class="line">0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, // d</span><br><span class="line">0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, // e</span><br><span class="line">0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d&#125;;// f</span><br></pre></td></tr></table></figure></p>
<h4 id="invmixcolumns">InvMixColumns</h4>
<p>InvMixColumns 是 MixColumns的逆序，需要用到的矩阵相乘系数为
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0e 0b 0d 09]   [s0  s4  s8  s12]</span><br><span class="line">[09 0e 0b 0d] . [s1  s5  s9  s13]</span><br><span class="line">[0d 09 0e 0b]   [s2  s6  s10 s14]</span><br><span class="line">[0b 0d 09 0e]   [s3  s7  s11 s15]</span><br></pre></td></tr></table></figure> <a
target="_blank" rel="noopener" href="https://blog.csdn.net/lisonglisonglisong/article/details/41909813">有限域
GF(2^8) 上的乘法改用查表的方式实现</a> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">byte Mul_09[256] = &#123;</span><br><span class="line">	0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,</span><br><span class="line">	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,</span><br><span class="line">	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,</span><br><span class="line">	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,</span><br><span class="line">	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,</span><br><span class="line">	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,</span><br><span class="line">	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,</span><br><span class="line">	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,</span><br><span class="line">	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,</span><br><span class="line">	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,</span><br><span class="line">	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,</span><br><span class="line">	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,</span><br><span class="line">	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,</span><br><span class="line">	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,</span><br><span class="line">	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,</span><br><span class="line">	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">byte Mul_0b[256] = &#123;</span><br><span class="line">	0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,</span><br><span class="line">	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,</span><br><span class="line">	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,</span><br><span class="line">	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,</span><br><span class="line">	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,</span><br><span class="line">	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,</span><br><span class="line">	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,</span><br><span class="line">	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,</span><br><span class="line">	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,</span><br><span class="line">	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,</span><br><span class="line">	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,</span><br><span class="line">	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,</span><br><span class="line">	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,</span><br><span class="line">	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,</span><br><span class="line">	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,</span><br><span class="line">	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">byte Mul_0d[256] = &#123;</span><br><span class="line">	0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,</span><br><span class="line">	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,</span><br><span class="line">	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,</span><br><span class="line">	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,</span><br><span class="line">	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,</span><br><span class="line">	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,</span><br><span class="line">	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,</span><br><span class="line">	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,</span><br><span class="line">	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,</span><br><span class="line">	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,</span><br><span class="line">	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,</span><br><span class="line">	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,</span><br><span class="line">	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,</span><br><span class="line">	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,</span><br><span class="line">	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,</span><br><span class="line">	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">byte Mul_0e[256] = &#123;</span><br><span class="line">	0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,</span><br><span class="line">	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,</span><br><span class="line">	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,</span><br><span class="line">	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,</span><br><span class="line">	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,</span><br><span class="line">	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,</span><br><span class="line">	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,</span><br><span class="line">	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,</span><br><span class="line">	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,</span><br><span class="line">	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,</span><br><span class="line">	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,</span><br><span class="line">	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,</span><br><span class="line">	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,</span><br><span class="line">	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,</span><br><span class="line">	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,</span><br><span class="line">	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>解密的AddRoundKey 与 加密的相同，只是将State和密钥做XOR操作。</p>
<h3 id="参考">参考</h3>
<p><a
target="_blank" rel="noopener" href="https://github.com/openluopworld/aes_128/blob/master/aes.c">aes算法实现</a>
<a
target="_blank" rel="noopener" href="https://github.com/dhuertas/AES/blob/master/aes.c">aes算法实现</a></p>
<h1 id="rsa">RSA</h1>
<p>给定一个正整数m，以及两个整数a,b，如果a-b被m整除，则称a与b模m同余，记作
$ a=b $，否则称a与b模m不同余，记作 $ a b $。</p>
<p><strong>欧拉函数</strong></p>
<p>意义是求跟某个数互素，且小于这个数的元素的个数。设数n，那么 <span
class="math inline">\(\phi(n)=|Z_n^\*|\)</span> 。<br />
与n互素且小于n的任意一个数，在计算模n的幂次的时候，等于1的那个最小的幂次。<br />
即 $ gcd(a,n)=1 <span class="math inline">\(，那么\)</span> a^{(n)}=1
$。</p>
<h2 id="rsa算法流程">RSA算法流程</h2>
<ol type="1">
<li>随机生成等二进制长度的两个素数: <span
class="math inline">\(p\)</span>、<span
class="math inline">\(q\)</span>；</li>
<li>计算 <span
class="math inline">\(\phi(n)=(p-1)\*(q-1)\)</span>，<span
class="math inline">\(n=p\*q\)</span>；</li>
<li>随机取值<span class="math inline">\(e\)</span>，使<span
class="math inline">\(e\)</span>与 <span
class="math inline">\(\phi(n)\)</span> 互素；</li>
<li>计算<span class="math inline">\(e\)</span>对 <span
class="math inline">\(\phi(n)\)</span> 的模逆，<span
class="math inline">\(e*d=1\pmod {\phi(n)}\)</span>；</li>
<li><span class="math inline">\((e, n)\)</span>为公钥，<span
class="math inline">\((d, n)\)</span>为私钥。</li>
</ol>
<ul>
<li>公钥加密</li>
</ul>
<p><span class="math display">\[ C = M^e \pmod {n} \]</span></p>
<ul>
<li>私钥解密</li>
</ul>
<p><span class="math display">\[ M = C^d \pmod {n} \]</span></p>
<ul>
<li>RSA signatures</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://cryptobook.nakov.com/digital-signatures/rsa-signatures">RSA
Signatures</a></p>
<ol type="1">
<li>计算消息的hash: <span
class="math inline">\(h=hash(msg)\)</span></li>
<li>用私钥 <span class="math inline">\(d\)</span> 加密消息hash: <span
class="math inline">\(s=h^d \pmod {n}\)</span></li>
</ol>
<ul>
<li>RSA signatures verification</li>
</ul>
<ol type="1">
<li>计算消息的hash: <span
class="math inline">\(h=hash(msg)\)</span></li>
<li>用公钥 <span class="math inline">\(e\)</span> 解密消息hash: <span
class="math inline">\(h&#39;=s^e \pmod {n}\)</span></li>
<li>比较 <span class="math inline">\(h\)</span> 与 <span
class="math inline">\(h&#39;\)</span> 是否相等</li>
</ol>
<h2 id="modular-exponentiation">Modular Exponentiation</h2>
<p>RSA 的操作主要是模幂运算，这里有 <em>Repeated
squaring</em>，<em>Sliding window</em>，<em>Chinese Remainder Theorem
(CRT)</em>，<em>Montgomery multiplication</em>，<em>Karatsuba
multiplication</em> 等。</p>
<h3 id="滑动窗口sliding-windows">滑动窗口：sliding windows</h3>
<p>Input: <span class="math inline">\(M\)</span>; <span
class="math inline">\(e\)</span>; <span
class="math inline">\(n\)</span>。<br />
Output: <span class="math inline">\(C = M^e \pmod {n}\)</span>.</p>
<ol type="1">
<li>Compute and store <span class="math inline">\(M^w \pmod {n}\)</span>
for all <span class="math inline">\(w = 3, 5, 7, ... , 2^d -
1\)</span>。</li>
<li>Decompose <span class="math inline">\(e\)</span> into zero and
nonzero windows <span class="math inline">\(F(i)\)</span> of length
<span class="math inline">\(L(F(i))\)</span>，for <span
class="math inline">\(i = 0, 1, 2, ... , p - 1\)</span>。</li>
<li><span class="math inline">\(C := M^{F(p-1)} \pmod {n}\)</span></li>
<li>for i = p - 2 down to 0
<ol type="1">
<li><span class="math inline">\(C := C^{2^{L(F(i))}} \pmod
{n}\)</span></li>
<li>if (F(i) != 0), then <span class="math inline">\(C := C * M^{F(i)}
\pmod {n}\)</span></li>
</ol></li>
<li>return C</li>
</ol>
<h3 id="crt-calculation">CRT calculation</h3>
<ul>
<li><a
target="_blank" rel="noopener" href="https://www.cscjournals.org/manuscript/Journals/IJCSS/Volume10/Issue5/IJCSS-1289.pdf">Implementation
of RSA Algorithm with Chinese Remainder Theorem for Modulus N 1024 Bit
and 4096 Bit</a></li>
</ul>
<p>简介中国剩余定理（Chinese Remainder Theorem，CRT）：</p>
<p>p和q是互相独立的大素数，n为p*q，对于任意(m1, m2), (0&lt;=m1&lt; p,
0&lt;=m2&lt; p) 必然存在一个唯一的m ,0&lt;=m&lt; n 使得</p>
<p><span class="math display">\[m1 = m \pmod {p}\]</span> <span
class="math display">\[m2 = m \pmod {q}\]</span></p>
<p>所以换句话说，给定一个(m1,m2)，其满足上述等式的m必定唯一存在。</p>
<p>通过中国剩余定理计算RSA。<br />
需要的参数：<br />
+ Modulus (<span class="math inline">\(n=pq\)</span>) + Public exponent
(<span class="math inline">\(e\)</span>，通常为3, 17 or 65537) + Private
exponent (<span class="math inline">\(d=e^{−1}\pmod {\phi(n)}\)</span>)
+ First prime (<span class="math inline">\(p\)</span>) + Second prime
(<span class="math inline">\(q\)</span>) + First exponent, used for
Chinese remainder theorem (<span
class="math inline">\(d_P=d\pmod{p−1}\)</span>) + Second exponent, used
for CRT (<span class="math inline">\(d_Q=d\pmod{q−1}\)</span>) +
Coefficient, used for CRT (<span
class="math inline">\(q_{inv}=q^{−1}\pmod{p}\)</span>)</p>
<p>公钥为 <span class="math inline">\((e, n)\)</span>，私钥为 <span
class="math inline">\((d_P, d_Q, q_{inv}, p, q)\)</span>。</p>
<ul>
<li>公钥加密</li>
</ul>
<p><span class="math display">\[ C = M^e \pmod {n} \]</span></p>
<ul>
<li>私钥解密</li>
</ul>
<p>这里和常规方法不同。</p>
<ol type="1">
<li>计算 <span class="math inline">\(C_p = C \pmod{p}\)</span>, <span
class="math inline">\(C_q = C \pmod{q}\)</span></li>
<li>计算 <span class="math inline">\(x_1={C_p}^{d_P}\pmod{p}\)</span> ,
<span class="math inline">\(x_2={C_q}^{d_Q}\pmod{q}\)</span></li>
<li>计算 <span class="math inline">\(h=q_{inv} \times
(x_1-x_2)\pmod{p}\)</span></li>
<li>明文 <span class="math inline">\(M = x_2+ {h}\times{q}\)</span></li>
</ol>
<h3 id="montgomery-multiplication">Montgomery Multiplication</h3>
<h2 id="padding-1">padding</h2>
<h3 id="pkcs1">PKCS1</h3>
<h3 id="oaep">OAEP</h3>
<p>OAEP (optimal asymmetric encryption padding)</p>
<h3 id="pss">PSS</h3>
<p><a target="_blank" rel="noopener" href="https://www.di-mgt.com.au/rsa_alg.html">RSA Algorithom
详尽的介绍</a></p>
<h1
id="paillier同态加密算法paillier-homomorphic-encryption">Paillier同态加密算法(Paillier
Homomorphic Encryption)</h1>
<p>Paillier加密系统是概率公钥加密系统。基于复合剩余类的困难问题。该加密算法是一种同态加密，满足加法和数乘同态。</p>
<h2 id="密钥生成">密钥生成：</h2>
<ul>
<li>随机选择两个大素数 <span class="math inline">\(p\)</span> , <span
class="math inline">\(q\)</span> ，即满足 $ gcd(pq,(p−1)(q−1))=1
$，这个属性是为了保证两个质数长度相等, <span
class="math inline">\(gcd()\)</span>用于计算两个数的最大公约数 。</li>
<li>计算 <span class="math inline">\(n=pq\)</span> , <span
class="math inline">\(\lambda=\mathrm{lcm}(p-1)(q-1)\)</span>， <span
class="math inline">\(lcm()\)</span> 用于计算最小公倍数。</li>
<li>随机选择一个整数 <span class="math inline">\(g\)</span> , <span
class="math inline">\(g\in \mathbb{Z}_{n^2}^*\)</span> ， 且满足 <span
class="math inline">\(gcd(L(g^{\lambda }{\bmod
n}^{2}),n)=1\)</span></li>
<li><span class="math inline">\(\mu =(L(g^{\lambda }{\bmod
n}^{2}))^{-1}{\bmod n}\)</span>，这里 <span
class="math inline">\(L\)</span> 被定义为 $L(x)= $.</li>
</ul>
<p><span class="math inline">\(\mathbb{Z}_{n^2}\)</span> 为小于 <span
class="math inline">\(n^2\)</span> 的整数集合，而<span
class="math inline">\(\mathbb{Z}_{n^2}^*\)</span> 为 <span
class="math inline">\(\mathbb{Z}_{n^2}\)</span> 中与 <span
class="math inline">\(n^2\)</span> 互质的整数的集合。</p>
<p><strong>公钥</strong>：<span class="math inline">\((n, g)\)</span>
<strong>私钥</strong>：<span class="math inline">\((\lambda,
\mu)\)</span> 。</p>
<h2 id="加密过程">加密过程：</h2>
<ul>
<li>m 是要被加密的明文，在这里 <span class="math inline">\(0 \leq m \lt
n\)</span>。</li>
<li>随机选择一个整数 <span class="math inline">\(r\)</span>, <span
class="math inline">\(0 \lt r \lt n\)</span>, <span
class="math inline">\(r \in \mathbb{Z}^*_{n^2}\)</span>, 与<span
class="math inline">\(n\)</span> 互质，即 <span
class="math inline">\(\mathrm{gcd}(r,n)=1\)</span>。<br />
</li>
<li>计算密文：<span class="math inline">\(c=g^{m}\cdot r^{n}{\bmod
n}^{2}\)</span></li>
</ul>
<p>对于任意明文 <span class="math inline">\(m \in
\mathbb{Z}_{n}\)</span>，随机选取的整数 <span
class="math inline">\(r\)</span>
不同，得到的密文就不同，但是解密后可以还原出相同的明文 <span
class="math inline">\(m\)</span> ，从而保证了m密文的语义安全。</p>
<h2 id="解密过程">解密过程：</h2>
<ul>
<li><span class="math inline">\(c\)</span> 是要解密的密文，<span
class="math inline">\(c \in \mathbb{Z}^*_{n^2}\)</span></li>
<li>计算明文：<span class="math inline">\(m=L(c^{\lambda }{\bmod
n}^{2})\cdot \mu {\bmod n}\)</span></li>
</ul>
<h2 id="证明">证明</h2>
<p><span class="math display">\[m=L(c^{\lambda }{\bmod  n}^{2})\cdot \mu
{\bmod  n}
=\frac{L(c^{\lambda }{\bmod  n}^{2})}{L(g^{\lambda }{\bmod  n}^{2})}
{\bmod n}\]</span></p>
<p>Carmichael’s theorem: <span class="math display">\[c^{\lambda}=(g^m
\cdot ⋅r^n )^{λ} = g^{mλ} \cdot r^{nλ} =g^{mλ} \]</span></p>
<p>多项式的幂次项: <span class="math display">\[(1+n)^x ≡1+nx \bmod
{n^2}\]</span></p>
<p><span class="math display">\[g^{mλ} =((1+n)^α\cdot β^n )^{λm}
=(1+n)^{αλm} \cdot β^{nλm} ≡(1+αλmn) \bmod {n^2}\]</span></p>
<p>应用 <span class="math inline">\(L()\)</span> 函数</p>
<p><span class="math display">\[\frac{L(c^{\lambda
}{\bmod  n}^{2})}{L(g^{\lambda }{\bmod  n}^{2})} {\bmod n} =
\frac{L(1+αλmn)}{L(1+αλn)} {\bmod n}=\frac{αλmn}{αλn} {\bmod n} =
m\]</span></p>
<h2 id="同态的性质">同态的性质</h2>
<h3 id="同态加法">同态加法</h3>
<ul>
<li>两个密文的乘积将解密为对应的明文之和</li>
</ul>
<p><span class="math display">\[ D(E(m_{1},r_{1})\cdot
E(m_{2},r_{2}){\bmod  n}^{2})=m_{1}+m_{2}{\bmod  n} \]</span></p>
<ul>
<li>一个密文与以 <span
class="math inline">\(g\)</span>为底、明文为幂的数相乘将解密为对应明文之和</li>
</ul>
<p><span class="math display">\[ D(E(m_{1},r_{1})\cdot
g^{m_{2}}{\bmod  n}^{2})=m_{1}+m_{2}{\bmod  n} \]</span></p>
<h3 id="同态乘法">同态乘法</h3>
<ul>
<li>密文的明文幂将倍解密为对应明文的乘积</li>
</ul>
<p><span class="math display">\[
D(E(m_{1},r_{1})^{m_{2}}{\bmod  n}^{2})=m_{1}m_{2}{\bmod  n} \]</span>
<span class="math display">\[
D(E(m_{2},r_{2})^{m_{1}}{\bmod  n}^{2})=m_{1}m_{2}{\bmod  n}\]</span>
更一般地， <span class="math display">\[
D(E(m_{1},r_{1})^{k}{\bmod  n}^{2})=km_{1}{\bmod  n}\]</span></p>
<p>参考： <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Paillier_cryptosystem#Key_generation">Paillier
cryptosystem</a><br />
<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41199831/article/details/81096625">Paillier算法详解及Java实现</a><br />
<a
target="_blank" rel="noopener" href="https://blog.csdn.net/caorui_nk/article/details/83305709">Paillier
Cryptosystem</a></p>
<h2 id="百万富翁安全比富问题">百万富翁安全比富问题</h2>
<p>安全多方计算起源于百万富翁问题（比谁更富有但不泄露财产），即两方安全函数计算（two-party
secure function evaluation，2P-SFE）。</p>
<p>安全多方计算在针对无可信第三方情况下，可让多个数据所有者在联合的数据上进行协同计算以提取数据的价值，而不泄露每个数据所有者的原始数据。在安全多方计算里节点通过隐私计算协议完成加密运算，核心思想是不让其他节点看到保密信息，确保在计算过程中对输入的数据保密，在不暴露明文的前提下完成某种运算。<br />
安全多方计算在云数据安全和隐私保护方面开始应用。</p>
<p>回到百万富翁比富问题，比较常见的是利用同态加密来实现。<br />
同样假设两个富翁Alice与Bob，财富分别是<span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>，安全比较过程如下：</p>
<p>第一步：Bob生成两个非常大的随机正整数 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> ，但是并不公开只有他自己知道；</p>
<p>第二步：Alice生成一对属于自己的密钥(公钥是<span
class="math inline">\(pub\)</span>，私钥是<span
class="math inline">\(pri\)</span>)，用公钥加密自己的财富的到 <span
class="math inline">\(E(a)\)</span> ，并将它和公钥一起公布出去；</p>
<p>第三步：Bob得到Alice公布出来的数据以后，首先用Alice公钥计算出 <span
class="math inline">\(E(b⋅x+y)\)</span>，然后用Paillier算法的同态属性计算出
<span
class="math inline">\(E(a⋅x+y)=E(a)x⋅E(y)\)</span>，并将这两个结果也公布出去；</p>
<p>第四步：Alice得到Bob公布出来的计算结果以后，用自己的私钥分别反解出
<span class="math inline">\(A=a⋅x+y\)</span> 和 <span
class="math inline">\(B=b⋅x+y\)</span> 的值。Alice虽然对 <span
class="math inline">\(x\)</span> 、 <span
class="math inline">\(y\)</span> 和 <span
class="math inline">\(b\)</span> 一无所知，但她只要比较 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 的大小就行了。而对于Bob来说，他对 <span
class="math inline">\(A\)</span> 、 <span
class="math inline">\(B\)</span> 和 <span
class="math inline">\(a\)</span>
也是一无所知，如果他也想要知道相对大小，要么Alice告诉他，要么把角色对换重新执行一遍协议即可。</p>
<p>Python代码可以参考<a
target="_blank" rel="noopener" href="https://www.dploop.org/2017-10-18-zhihu66376147/">两个百万富翁如何安全比富</a></p>
<h1 id="零知识证明-zero-knowledge-proof">零知识证明 Zero-knowledge
proof</h1>
<p>零知识证明(Zero—Knowledge
Proof)，指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。大量事实证明，零知识证明在密码学中非常有用。如果能够将零知识证明用于验证，将可以有效解决许多问题。</p>
<p>在密码应用中，Peggy想要向Victor证明她知道在给定群中的给定值的离散对数。比如，对于给定值
<span class="math inline">\(y\)</span> ，素数 <span
class="math inline">\(p\)</span> ，生成元 <span
class="math inline">\(g\)</span> ，她想证明她知道满足 <span
class="math inline">\(g^{x}{\bmod {p}}=y\)</span> 的 <span
class="math inline">\(x\)</span> ，而不泄露 <span
class="math inline">\(x\)</span> 。 Victor想要确定她是否知道 <span
class="math inline">\(x\)</span> 的过程如下。</p>
<ol type="1">
<li>Peggy第一次计算 <span class="math inline">\(g^{x}{\bmod
{p}}=y\)</span> 并将 <span class="math inline">\(y\)</span> 传给
Victor。</li>
<li>Peggy选择随机数 <span class="math inline">\(r\)</span> ，并计算 $
C=g^{r}{} $ 再将计算结果传给 Victor。</li>
<li>Victor 向 Peggy请求 $ (x+r){} $ ，并且验证 $ (Cy){}g^{(x+r){}}{} $
。</li>
<li>Victor 重复向Peggy 请求随机数并作验证。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zero-knowledge_proof"
class="uri">https://en.wikipedia.org/wiki/Zero-knowledge_proof</a></p>
<h1 id="离散对数体系discrete-logarithm">离散对数体系（Discrete
Logarithm）</h1>
<p>实现离散对数体制的最常用的群是有限域的乘法群的循环子群和椭圆曲线群的循环子群。</p>
<h2 id="困难问题">困难问题</h2>
<ul>
<li>离散对数问题discrete logarithm problem</li>
</ul>
<p>给定素数 <span class="math inline">\(p\)</span> 和正整数 <span
class="math inline">\(g\)</span> ，知道 <span class="math inline">\(g^x
\pmod{p}\)</span> 的值，求 <span class="math inline">\(x\)</span> 。</p>
<ul>
<li>椭圆曲线上的离散对数问题 elliptic curve discrete logarithm
problem</li>
</ul>
<p>k为正整数，P 是椭圆曲线上的点，已知 <span
class="math inline">\(P^k\)</span> 和 <span
class="math inline">\(P\)</span> ，计算 <span
class="math inline">\(k=\log_{P}{P^k}\)</span> 。</p>
<p><a
target="_blank" rel="noopener" href="https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc#elliptic-curve-discrete-logarithm-problem-ecdlp">Elliptic-Curve
Discrete Logarithm Problem (ECDLP)</a></p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/qmickecs/article/details/76585303">离散对数和椭圆曲线加密原理</a></p>
<h2 id="d-h">D-H</h2>
<p>第一个离散对数体制是Diffie-Hellman于1976年提出的密钥协商协议。1984年，ElGamal提出了离散对数公钥加密方案和离散对数签名方案。以后，人们相机提出了离散对数公钥密码的各种变种。
下面介绍基本的ElGamal公钥加密方案和密钥签名方案（DSA）。</p>
<p><code>模除</code>（又称模数、取模操作、取模运算等，英语：
<code>modulo</code> 有时也称作
<code>modulus</code>）得到的是一个数除以另一个数的余数。</p>
<p>Diffie–Hellman key exchange<a
target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">[2]</a>，迪菲-赫尔曼密钥交换，是一种安全协议。它能够让通信双方在没有对方任何预先信息的前提下通过不安全信道进行密钥交换。它是无认证的密钥交换协议。目的是创建一个可以用于公共信道上安全通信的共享秘密（shared
secret）。</p>
<figure>
<img src="../密码学EXM/Diffie-Hellman-Schlüsselaustausch.svg"
alt="Diffie-Hellman流程图" />
<figcaption aria-hidden="true">Diffie-Hellman流程图</figcaption>
</figure>
<ol type="1">
<li>通信双方爱丽丝A和鲍勃B两人，再通信前约定好生成元g和质数p。（此g可以被攻击者捕获）</li>
<li>爱丽丝A随机选择一个自然数a并且将g^a mod p发送给鲍勃B。</li>
<li>鲍勃B随机选择一个自然数b并且将g^b mod p 发送给爱丽丝A。</li>
<li>爱丽丝A计算(g^b mod p)^a mod p。</li>
<li>鲍勃B计算(g^a mod p)^b mod p。</li>
<li>爱丽丝A和鲍勃B最终得到了相同的值，协商出的群元素g^(ab)作为共享密钥。</li>
</ol>
<h2
id="基于椭圆曲线的dh密钥交换ecdh">基于椭圆曲线的DH密钥交换（ECDH）</h2>
<p>ECDH跟DH的流程基本是一致的。</p>
<ol type="1">
<li>爱丽丝A 和 鲍勃B
约定使用某条椭圆曲线（包括曲线参数，有限域参数以及基点P等）</li>
<li>爱丽丝A 生成私钥 x，计算 <span class="math inline">\(x∗P\)</span>
作为公钥公布出去</li>
<li>鲍勃B 生成私钥 <span class="math inline">\(y\)</span>，计算 <span
class="math inline">\(y∗P\)</span> 作为公钥公布出去</li>
<li>爱丽丝A 得知 <span class="math inline">\(y∗P\)</span> 后，计算<br />
<span class="math inline">\(s=x∗(y∗P)=xy∗P\)</span><br />
</li>
<li>鲍勃B 得到 x∗P 后，计算<br />
<span class="math inline">\(s=y∗(x∗P)=yx∗P\)</span><br />
</li>
<li>双方都得到了相同的密钥的 s，交换完毕</li>
</ol>
<p>D-H具体实现分为 <em>基于离散对数</em> 和
<em>基于椭圆曲线离散对数</em> 两种。
两种方法的密钥安全等级如下，对于同样的安全等级，椭圆曲线密钥长度比离散对数密钥长度要小得多。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 29%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th>Security level in bits</th>
<th>Discrete log key bits</th>
<th>Elliptic curve key bits</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>56</td>
<td>512</td>
<td>112</td>
</tr>
<tr class="even">
<td>80</td>
<td>1024</td>
<td>160</td>
</tr>
<tr class="odd">
<td>112</td>
<td>2048</td>
<td>224</td>
</tr>
<tr class="even">
<td>128</td>
<td>3072</td>
<td>256</td>
</tr>
<tr class="odd">
<td>256</td>
<td>15360</td>
<td>512</td>
</tr>
</tbody>
</table>
<p>D-H容易遭受
man-in-the-middle，即MITM（中间人）攻击。因为消息没有认证。</p>
<h2 id="elgamal加密算法">ElGamal加密算法</h2>
<p>定义可以参见<a
target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/crypto/signature/elgamal/"
class="uri">https://ctf-wiki.github.io/ctf-wiki/crypto/signature/elgamal/</a></p>
<p>非常详细的ElGamal加密的教程，给了循环组的例子。 <a
target="_blank" rel="noopener" href="https://ritter.vg/security_adventures_elgamal.html"
class="uri">https://ritter.vg/security_adventures_elgamal.html</a></p>
<p>ElGamal加密算法是一个基于 Diffie-Hellman 密钥交换的非对称加密算法。
ElGamal加密算法由三部分组成：密钥生成、加密和解密。</p>
<h3 id="密钥生成-1">密钥生成</h3>
<p>密钥生成的步骤如下：</p>
<ul>
<li>Alice利用生成元 <span class="math inline">\({g}\)</span>
产生一个大素数 <span class="math inline">\(q\)</span>,即<span
class="math inline">\(g\)</span>是<span
class="math inline">\(q\)</span>的本原根，阶循环群 <span
class="math inline">\(G\)</span>的有效描述，该循环群的阶为 <span
class="math inline">\(q-1\)</span>。该循环群需要满足一定的安全性质。[
[本原根的概念对应模q乘法群(需循环群)中的生成元。]]</li>
<li>Alice从 <span class="math inline">\(\lbrace1,\ldots
,q-1\rbrace\)</span>中随机选择一个 <span
class="math inline">\(x\)</span>。</li>
<li>Alice计算 <span class="math inline">\(h:=g^{x}\)</span>。</li>
<li>Alice公开 <span class="math inline">\(h\)</span>,以及 <span
class="math inline">\(G,q,g\)</span>的描述作为其公钥，并保留 <span
class="math inline">\(x\)</span> 作为其私钥。私钥必须保密。</li>
</ul>
<h3 id="加密">加密</h3>
<p>使用Alice的公钥 <span
class="math inline">\((G,q,g,h)\)</span>向她加密一条消息 <span
class="math inline">\(m\)</span> 的加密算法工作方式如下：</p>
<ul>
<li>Bob从 <span class="math inline">\(\lbrace1,\ldots
,q-1\rbrace\)</span> 随机选择一个 <span
class="math inline">\(y\)</span>，然后计算 <span
class="math inline">\(c_{1}:=g^{y}\)</span>。</li>
<li>Bob计算共享秘密 <span class="math inline">\(s:=h^{y}\)</span>。</li>
<li>Bob把他要发送的秘密消息 <span class="math inline">\(m\)</span>
映射为 <span class="math inline">\(G\)</span> 上的一个元素 <span
class="math inline">\(m&#39;\)</span>。</li>
<li>Bob计算 <span class="math inline">\(c_{2}:=m&#39;\cdot
s\)</span>。</li>
<li>Bob将密文 <span
class="math inline">\((c_{1},c_{2})=(g^{y},m&#39;\cdot
h^{y})=(g^{y},m&#39;\cdot (g^{x})^{y})\)</span>发送给Alice。</li>
</ul>
<p>值得注意的是，如果一个人知道了 <span
class="math inline">\(m&#39;\)</span>，那么它很容易就能知道 <span
class="math inline">\(h^{y}\)</span>的值。因此对每一条信息都产生一个新的
<span class="math inline">\(y\)</span> 可以提高安全性。所以 <span
class="math inline">\(y\)</span> 也被称作临时密钥。</p>
<h3 id="解密">解密</h3>
<p>利用私钥 <span class="math inline">\(x\)</span> 对密文 <span
class="math inline">\((c_{1},c_{2})\)</span>进行解密的算法工作方式如下：</p>
<ul>
<li>Alice计算共享秘密 <span
class="math inline">\(s:=c_{1}{}^{x}\)</span> 然后计算 <span
class="math inline">\(m&#39;:=c_{2}\cdot
s^{-1}\)</span>，并将其映射回明文 <span
class="math inline">\(m\)</span>，其中 <span
class="math inline">\(s^{-1}\)</span> 是 <span
class="math inline">\(s\)</span> 在群 <span
class="math inline">\(G\)</span> 上的逆元。（例如：如果 <span
class="math inline">\(G\)</span>
是整数模n乘法群的一个子群，那么逆元就是模逆元）。
解密算法是能够正确解密出明文的，因为 <span
class="math inline">\(c_{2}\cdot s^{-1}=m&#39;\cdot h^{y}\cdot
(g^{xy})^{-1}=m&#39;\cdot g^{xy}\cdot g^{-xy}=m&#39;.\)</span></li>
</ul>
<p>同样参考 <a
target="_blank" rel="noopener" href="https://www.jianshu.com/p/cd36ae7dca47">ElGamal加密算法</a></p>
<h2 id="elgamal签名算法">ElGamal签名算法</h2>
<p>ElGamal 来说，其签名方案与相应的加密方案具有很大区别。</p>
<p><strong>补充</strong>： 在同余理论中，模 n
的互质同余类组成一个乘法群，称为整数模 n 乘法群。 &gt; In modular
arithmetic, the integers coprime (relatively prime) to n from the set
{0,1,... ,n-1} of n non-negative integers form a group under
multiplication modulo n, called the multiplicative group of integers
modulo n.</p>
<p><strong>补充</strong>： 扩展欧几里得算法（英语：Extended Euclidean
algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式</p>
<p>$ ax + by = (a, b)$</p>
<h3 id="密钥生成-2">密钥生成</h3>
<ol type="1">
<li>选取一个足够大的素数 <span
class="math inline">\(p\)</span>（十进制位数不低于 160），以便于在<span
class="math inline">\(Z_p\)</span>上求解离散对数问题是困难的。</li>
<li>选取整数模 <span class="math inline">\(p\)</span> 乘法群<span
class="math inline">\(Z_{p}^{*}\)</span> 的生成元 <span
class="math inline">\(g\)</span>。</li>
<li>随机选取密钥 <span class="math inline">\(x\)</span>，满足 <span
class="math inline">\(1 &lt; x &lt; p − 2\)</span>，计算 <span
class="math inline">\(y = g^x \bmod p\)</span> 。</li>
</ol>
<p>其中私钥为 <span class="math inline">\({x}\)</span>，公钥为 <span
class="math inline">\({p,g,y}\)</span> 。</p>
<h3 id="签名">签名</h3>
<p>如果A 要对消息 <span class="math inline">\(m\)</span> 进行签名 <span
class="math inline">\(sig_d(m,k)=(r,s)\)</span> ，过程为： 1. 选取随机数
<span class="math inline">\(k\)</span> ，满足 <span
class="math inline">\(1 &lt; k &lt; p − 1\)</span> ，并且 <span
class="math inline">\(gcd(k,p-1)=1\)</span>。 2. 计算 <span
class="math inline">\(r\,\equiv \,g^{k}{\pmod {p}}\)</span> 3.
利用扩展欧几里得公式 <span class="math inline">\(m \, \equiv \, x r + s
k \pmod{p-1}\)</span>，计算 <span class="math inline">\(s\,\equiv
\,(m-xr)k^{-1}{\pmod {p-1}}\)</span> 。 4. 如果 <span
class="math inline">\(s=0\)</span> ， 重新计算。</p>
<p>对 <span class="math inline">\(m\)</span> 的签名结果为 <span
class="math inline">\((r,s)\)</span> 。</p>
<h3 id="验证">验证</h3>
<p>B拿到消息和消息的签名结果验证阶段： 如果 <span
class="math inline">\(g^m\, \equiv \, y^{r}r^{s} {\pmod {p}}\)</span>
，那么验证成功，否则验证失败。</p>
<p>由于 <span class="math inline">\(m \, \equiv \, x r + s k
\pmod{p-1}\)</span> <span class="math display">\[
\begin{align}
g^{m} &amp; \equiv g^{xr} g^{ks} \\
&amp; \equiv (g^{x})^r (g^{k})^s \\
&amp; \equiv (y)^r (r)^s \pmod p.\\
\end{align}\]</span></p>
<h2 id="dsa--digital-signature-algorithm">DSA -Digital Signature
Algorithm</h2>
<p>Digital Signature Algorithm
(DSA)是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature
Standard)。 专门用于签名和验签。
DSA是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。</p>
<h3 id="密钥生成-3">密钥生成</h3>
<p>密钥生成有两个阶段。<br />
第一阶段，是公开的参数信息。 1. 选择一个合适的哈希函数 <span
class="math inline">\(H\)</span>，目前一般选择
SHA1，当前也可以选择强度更高的哈希函数 如 SHA2。 2. 选择密钥的长度 <span
class="math inline">\(L\)</span> 和 <span
class="math inline">\(N\)</span>，这两个值决定了签名的安全程度。在最初的
DSS（Digital Signature Standard ）中建议 <span
class="math inline">\(L\)</span> 必须为 64 的倍数，并且 <span
class="math inline">\(512 ≤ L ≤ 1024\)</span>，当然，也可以更大。 <span
class="math inline">\(N\)</span> 必须不大于哈希函数 <span
class="math inline">\(H\)</span> 输出的长度。FIPS 186-3 给出了一些建议的
L 和 N 的取值例子：(1024, 160)， (2048, 224)， (2048, 256)，以及 (3,072,
256)。 3. 选择 <span class="math inline">\(N\)</span> 比特的素数 <span
class="math inline">\(q\)</span> , <span
class="math inline">\(N\)</span> 长度小于或等于哈希函数输出长度。 4.
选择 <span class="math inline">\(L\)</span> 比特的素数 <span
class="math inline">\(p\)</span>，使得 <span
class="math inline">\(p-1\)</span> 是 <span
class="math inline">\(q\)</span> 的倍数。 5. 选择 <span
class="math inline">\(g\)</span> ，其模<span
class="math inline">\(p\)</span> 的乘阶为 <span
class="math inline">\(q\)</span> ，意味着 <span
class="math inline">\(q\)</span> 是满足 <span
class="math inline">\(g^q=1\pmod p\)</span> 最小的正整数，即 <span
class="math inline">\(ord_p(g)=p\)</span>。 即 <span
class="math inline">\(g\)</span> 在模 <span
class="math inline">\(p\)</span> 的意义下，其指数次幂可以生成具有 <span
class="math inline">\(q\)</span> 个元素的子群。这里，我们可以通过计算
<span class="math inline">\(g = h^ {\frac {p − 1} {q} }\pmod
{p}\)</span> 来得到 <span class="math inline">\(g\)</span>，其中 <span
class="math inline">\(1 &lt; h &lt; p − 1\)</span> 。 大部分的 <span
class="math inline">\(h\)</span> 选择会导致可使用的 <span
class="math inline">\(g\)</span> ，通常 <span
class="math inline">\(h=2\)</span> 。</p>
<p><span class="math inline">\((p, g, q)\)</span>会在不同的系统间公开。
第二阶段，计算公钥和私钥。 选择私钥 <span
class="math inline">\(x\)</span>，使其满足 <span class="math inline">\(0
&lt; x &lt; q\)</span> ，计算 <span class="math inline">\(y ≡ g^x mod
p\)</span> 。<br />
公钥为 <span class="math inline">\((p, q, g, y)\)</span> 。</p>
<h3 id="签名-1">签名</h3>
<ol type="1">
<li>选择随机整数数 k 作为<em>临时密钥</em>， $ 0 &lt; k &lt; q $。</li>
<li>计算 $r ≡ (g^k ) $</li>
<li>计算 <span class="math inline">\(s ≡ (H(m) + x r ) k^{−1} \pmod
{q}\)</span> 。</li>
</ol>
<p>签名结果为 <span
class="math inline">\((r,s)\)</span>。<strong>需要注意的是，这里与
Elgamal
很重要的不同是这里使用了哈希函数对消息进行了哈希处理</strong>。</p>
<p>可以利用扩展欧几里得算法计算 模逆 <span class="math inline">\(k^{−1}
\pmod {q}\)</span> ，或者使用费马小定理。</p>
<p>由于签名者 既不知道 私钥 <span class="math inline">\(x\)</span>
，又不知道随机数 <span class="math inline">\(k\)</span> ，在验证 <span
class="math inline">\(s ≡ (H(m) + x r ) k^{−1} \pmod {q}\)</span>
时，需要将其转换成 $ k ≡ (H(m) + x r ) s^{−1} $ 。<br />
两边作 <span class="math inline">\(g\)</span> 的幂指数，得到 $ g^k ≡
g<sup>{H(m)k</sup>{-1}}y<sup>{rs</sup>{-1}} $ 。
所以，验签者可以计算等式右边，等式左边是 <span
class="math inline">\(r\)</span> ，那么可以判断等式是否成立。</p>
<h3 id="验证-1">验证</h3>
<ol type="1">
<li>先判断 $ 0 &lt; r &lt;q $ 或者 $ 0 &lt; s &lt; q $
是否满足条件，如果不满足，则不验签。</li>
<li>计算 $w=s^{-1}{}q $</li>
<li>计算 $ u_{1}=H(m)w,{}q $</li>
<li>计算 $ u_{2}=rw,{}q $</li>
<li>计算 $ v=(g<sup>{u_{1}}y</sup>{u_{2}}{}p){}q $</li>
</ol>
<p>如果 $ v = r $ ， 那么签名有效。</p>
<h3 id="正确性证明">正确性证明</h3>
<p>签名者计算 <span class="math display">\[ s ≡ (H(m) + x r ) k^{−1}
\pmod {q}\]</span> ， 可得 <span class="math display">\[
\begin{align}
k &amp; \equiv H(m)s^{-1}+xrs^{-1}\\
  &amp; \equiv H(m)w + xrw \pmod{q}
\end{align}
\]</span></p>
<p>费马小定理 $ g^q ≡ h^{p − 1} ≡ 1 $ ，且 $ g &gt;1 $ , <span
class="math inline">\(q\)</span> 是质数， 因此 <span
class="math inline">\(g\)</span> 有 <span class="math inline">\(q
\pmod{p}\)</span> 阶。<br />
<span class="math display">\[
\begin{align}
g^{k}&amp;\equiv g^{H(m)w}g^{xrw}\\
    &amp;\equiv g^{H(m)w}y^{rw}\\
    &amp;\equiv g^{u_{1}}y^{u_{2}}{\pmod {p}}
\end{align}
\]</span></p>
<p>DSA的正确性可从下式得出： <span class="math display">\[
\begin{align}
r&amp;=(g^{k}{\bmod {\,}}p){\bmod {\,}}q\\
&amp;=(g^{u_{1}}y^{u_{2}}{\bmod {\,}}p){\bmod {\,}}q\\
&amp;=v
\end{align}
\]</span></p>
<h2 id="ecdsa">ECDSA</h2>
<p>随机数很重要！ &gt; The ECDSA digital signature has a drawback
compared to RSA in that it requires a good source of entropy.<br />
Without proper randomness, the private key could be revealed.<br />
A flaw in the random number generator on Android allowed hackers to find
the ECDSA private key used to protect the bitcoin wallets of several
people in early 2013.<br />
Sony's Playstation implementation of ECDSA had a similar
vulnerability.<br />
A good source of random numbers is needed on the machine making the
signatures. Dual_EC_DRBG is not recommended.</p>
<p>from <a
target="_blank" rel="noopener" href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">A
(Relatively Easy To Understand) Primer on Elliptic Curve
Cryptography</a></p>
<h1 id="elliptic-curve-cryptography-ecc">Elliptic Curve Cryptography
(ECC)</h1>
<p><a
target="_blank" rel="noopener" href="https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc">Elliptic
Curve Cryptography (ECC)</a></p>
<p>基于椭圆曲线的密码算法包括：</p>
<ol type="1">
<li><p>ECC签名算法，比如ECDSA和EdDSA</p></li>
<li><p>ECC加密算法，比如ECIES integrated encryption scheme and EEECC
(EC-based ElGamal).</p></li>
<li><p>ECC密钥协商，比如ECDH、X25519。</p></li>
</ol>
<p>ECC算法可以选取不同的椭圆曲线，根据曲线的不同，安全等级、密钥长度、计算速度也不同。<br />
比如 <code>secp256k1</code> 和 <code>Curve25519</code> 。<br />
一般，ECC私钥长度为 256 bits，但是也分曲线。比如 192-bit (curve
secp192r1), 233-bit (curve sect233k1), 224-bit (curve secp224k1),
256-bit (curves secp256k1 and Curve25519), 283-bit (curve sect283k1),
384-bit (curves p384 and secp384r1), 409-bit (curve sect409r1), 414-bit
(curve Curve41417), 448-bit (curve Curve448-Goldilocks), 511-bit (curve
M-511), 521-bit (curve P-521), 571-bit (curve sect571k1)。</p>
<p>椭圆曲线的函数表示： <span class="math inline">\(y^2 = x^3 + a*x +
b\)</span><br />
例如，对于 secp256k1，<span class="math inline">\(y^2 = x^3 +
7\)</span>，a=0,b=7。</p>
<p>椭圆曲线上的操作包括点加（ EC point addition），点乘（EC point
multiplication）。</p>
<p>椭圆曲线的几点要素：<br />
+ Еlliptic curve (EC) over finite field <span
class="math inline">\(𝔽_p\)</span> + <span
class="math inline">\(G\)</span> == generator point (fixed constant, a
base point on the EC) + <span class="math inline">\(k\)</span> ==
private key (integer) + <span class="math inline">\(P\)</span> == public
key (point)</p>
<p>私钥是 一个整数，公钥是一个椭圆曲线上的点(EC point)，<span
class="math inline">\(P = k * G\)</span>。</p>
<p>有限域上的椭圆曲线的点构成了循环群，因此定义曲线的阶数
<code>order</code> 为EC全部的点。<br />
定义无穷远点为 任一点乘以 0 得到的点。<br />
但是有些曲线会生成若干<span
class="math inline">\(h\)</span>循环子群，每个子群的阶数为<span
class="math inline">\(r\)</span>，因此整个群的阶数为 <span
class="math inline">\(n=h*r\)</span>。</p>
<ul>
<li>Curve25519</li>
</ul>
<p><span class="math inline">\(y^2 = x^3 + 486662x^2 + x\)</span></p>
<h1 id="国产密码算法">国产密码算法</h1>
<p>国产密码算法（国密算法）是指国家密码局认定的<code>国产商用密码算法</code>，在金融领域目前主要使用公开的SM2、SM3、SM4三类算法，分别是非对称算法、哈希算法和对称算法。
其中<code>SM</code>代表“商密”，即用于商用的、不涉及国家秘密的密码技术。</p>
<h2 id="sm2椭圆曲线公钥密码算">SM2椭圆曲线公钥密码算</h2>
<p>SM2椭圆曲线公钥密码算法是我国自主设计的公钥密码算法，包括
<strong>SM2-1椭圆曲线数字签名算法</strong>，<strong>SM2-2椭圆曲线密钥交换协议</strong>，<strong>SM2-3椭圆曲线公钥加密算法</strong>，分别用于实现数字签名密钥协商和数据加密等功能。SM2算法与RSA算法不同的是，SM2算法是基于椭圆曲线上点群离散对数难题，相对于RSA算法，256位的SM2密码强度已经比2048位的RSA密码强度要高。</p>
<p>SM2 <span class="math inline">\(F_p-256\)</span> 椭圆曲线选取：<br />
<span class="math display">\[y^2 = x^3 + ax + b\]</span>
曲线参数：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFF</span><br><span class="line">a=FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFC</span><br><span class="line">b=28E9FA9E 9D9F5E34 4D5A9E4B CF6509A7 F39789F5 15AB8F92 DDBCBD41 4D940E93</span><br><span class="line">n=FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF 7203DF6B 21C6052B 53BBF409 39D54123</span><br><span class="line">Gx=32C4AE2C 1F198119 5F990446 6A39C994 8FE30BBF F2660BE1 715A4589 334C74C7</span><br><span class="line">Gy=BC3736A2 F4F6779C 59BDCEE3 6B692153 D0A9877C C62A4740 02DF32E5 2139F0A0</span><br></pre></td></tr></table></figure></p>
<p><a
target="_blank" rel="noopener" href="https://github.com/openssl/openssl/tree/master/crypto/sm2">OpenSSL
SM2代码</a></p>
<h3 id="sm2-椭圆曲线数字签名算法">SM2-椭圆曲线数字签名算法</h3>
<h3 id="sm2-椭圆曲线密钥交换协议">SM2-椭圆曲线密钥交换协议</h3>
<h3 id="sm2-椭圆曲线公钥加密算法">SM2-椭圆曲线公钥加密算法</h3>
<h2 id="sm3杂凑算法">SM3杂凑算法</h2>
<p>SM3杂凑算法是我国自主设计的密码杂凑算法，适用于商用密码应用中的数字签名和验证消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。为了保证杂凑算法的安全性，其产生的杂凑值的长度不应太短，例如MD5输出128比特杂凑值，输出长度太短，影响其安全性SHA-1算法的输出长度为160比特，SM3算法的消息分组长度是512比特，输出长度为256比特，因此SM3算法的安全性要高于MD5算法和SHA-1算法。</p>
<p>整个算法的执行过程可以概括成四个步骤：消息填充、迭代压缩、输出结果。</p>
<h3 id="消息填充">消息填充</h3>
<p>由于分组长度为512比特，把数据长度填充至512位的倍数。<br />
首先在数据末尾填充一个比特<code>1</code>，而后在后面填充k个0，k满足(n+1+k)
mod 512 =
448的最小正整数。这是为了保证最后填充的64位存储真实有效的原始数据长度，</p>
<p>这里存在着这种情况，如果最后一分组的有效数据长度超过448，那么需要再创建一个512的分组。</p>
<h3 id="迭代压缩">迭代压缩</h3>
<p>将消息按照512分组进行迭代压缩。 每轮的迭代过程为：<br />
<span class="math display">\[V^{(i+1)} = CF(V^{(i)},
B^{(i)})\]</span></p>
<p>其中 <span class="math inline">\(CF\)</span> 是压缩函数，<span
class="math inline">\(V^{(0)}\)</span> 为256比特初始值<span
class="math inline">\(IV\)</span>，<span
class="math inline">\(B^{(i)}\)</span>
为填充后的消息分组，迭代压缩的结果为<span
class="math inline">\(V^{(n)}\)</span>。</p>
<p>对于压缩函数计算过程，SM3没有直接使用原始消息，而是SM3使用
<strong>消息扩展</strong> 得到的消息字进行运算。</p>
<p>压缩函数的初值IV被放在A、B、C、D、E、F、G、H八个32位变量中，需要进行64轮迭代，每轮的输出再作为下一轮压缩函数时的初值。</p>
<p>将得到的A、B、C、D、E、F、G、H八个变量拼接输出，就是SM3算法的输出。</p>
<p>kernel中sm3实现在 <em>crypto/sm3_generic.c</em></p>
<h2 id="sm4分组密码算法">SM4分组密码算法</h2>
<p>SM4分组密码算法是我国自主设计的分组对称密码算法，用于实现数据的加密/解密运算，以保证数据和信息的机密性。
要保证一个对称密码算法的安全性的基本条件是其具备足够的密钥长度，SM4算法与AES算法具有相同的密钥长度/分组长度128比特，因此在安全性上高于3DES算法。</p>
<p>SM4加密算法与密钥扩展算法都采用 32
轮非线性迭代结构。数据解密和数据加密的算法结构相同，
只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p>
<p>该分组密码算法实现相对简单，也同样分为密钥扩展算法、加密和解密算法。
字节按照大端序处理。</p>
<ul>
<li>每一轮的轮函数 <span class="math inline">\(F\)</span>：</li>
</ul>
<p><span class="math display">\[𝐹(𝑋_0, 𝑋_2, 𝑋_3, 𝑋_4, 𝑟𝑘) =
𝑋_0\bigoplus𝑇(𝑋_2 \bigoplus 𝑋_3 \bigoplus 𝑋_4 \bigoplus 𝑟𝑘)\]</span>
其中，输入 <span class="math inline">\((𝑋_0, 𝑋_2, 𝑋_3, 𝑋_4)\)</span>
为4个32bit的字， <span class="math inline">\(rk\)</span>
为当前32bit的轮密钥，<span class="math inline">\(T\)</span>
为可逆变换，由字节替换(SBox)和循环向左移位异或两部组成。</p>
<p><span class="math display">\[T(x) = L(\tau(x))\]</span> 其中， <span
class="math inline">\(\tau(x)\)</span> 为非线性变换，将 32bit 的 <span
class="math inline">\(x\)</span> 的每个字节使用 SBox 替换。 <span
class="math inline">\(L(x)= x \bigoplus (x&lt;&lt;&lt;2) \bigoplus
(x&lt;&lt;&lt;10) \bigoplus (x&lt;&lt;&lt;18) \bigoplus
(x&lt;&lt;&lt;24)\)</span></p>
<p>循环左移可参见宏<br />
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROTL(x, shift)	(((x)<span class="string">&lt;&lt;(shift&amp;(32-1))) | ((x)&gt;</span>&gt;(32-(shift&amp;(32-1)))))</span></span><br></pre></td></tr></table></figure></p>
<h3 id="密钥扩展算法">密钥扩展算法</h3>
<p>密钥扩展算法需要辅助参数 <span class="math inline">\(FK\)</span> 和
<span class="math inline">\(CK\)</span> ，</p>
<p>加密密钥为 <span class="math inline">\(MK=(MK_0, MK_1, MK_2,
MK_3)\)</span>， 则首先生成首轮轮密钥： <span
class="math inline">\((K_0, K_1, K_2, K_3)=(MK_0 \bigoplus FK_0, MK_1
\bigoplus FK_1, MK_2 \bigoplus FK_2, MK_3 \bigoplus
FK_3)\)</span>。<br />
则32个轮密钥都由前3个产生，即 <span
class="math display">\[rk_i=K_{i+4}=K_i \bigoplus T&#39;(K_{i+1}
\bigoplus K_{i+2} \bigoplus K_{i+3} \bigoplus CK_{i})\]</span></p>
<p><span class="math inline">\(T&#39;()\)</span> 是将合成转置中的 <span
class="math inline">\(L\)</span> 替换成 <span
class="math inline">\(L&#39;\)</span>，即 <span
class="math inline">\(L&#39;(x) = x \bigoplus (x&lt;&lt;&lt;13)
\bigoplus (x&lt;&lt;&lt;23)\)</span> 。</p>
<h3 id="加密算法">加密算法</h3>
<p>进行32次迭代计算： <span
class="math display">\[X_{i+4}=F(X_i,X_{i+1},X_{i+2},X_{i+3},𝑟𝑘_{i})\]</span></p>
<p>将最后结果反序：</p>
<p><span class="math display">\[(Y_0,Y_1,Y_2,Y_3) =
R(X_{32},X_{33},X_{34},X_{35}) =
(X_{35},X_{34},X_{33},X_{32})\]</span></p>
<h3 id="解密算法">解密算法</h3>
<p>本算法的解密变换与加密变换结构相同，不同的仅是轮密钥的使用顺序。解密时，使用
轮密钥序 <span
class="math inline">\((rk_{31},rk_{30},...,rk_{0})\)</span>。</p>
<p>kernel中sm3实现在 <em>crypto/sm4_generic.c</em>，用户态实现见<a
target="_blank" rel="noopener" href="https://github.com/fengkx/sm4">sm4实现</a>、 <a
target="_blank" rel="noopener" href="https://github.com/windard/sm4">SM4实现</a>。</p>
<h2 id="祖冲之序列密码算法">祖冲之序列密码算法</h2>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="http://www.cnblogs.com/songwenlong/p/5944139.html">安全体系（一）——
DES算法详解</a></li>
<li><a
target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">迪菲-赫尔曼密钥交换</a></li>
<li><a
target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">分组密码工作模式</a></li>
<li><a
target="_blank" rel="noopener" href="http://www.cnblogs.com/luop/p/4334160.html">密码算法详解——AES</a></li>
<li><a
target="_blank" rel="noopener" href="http://www.gmbz.org.cn/upload/2018-03-24/1521879142922000396.pdf">密码标准应用指南</a></li>
<li><a target="_blank" rel="noopener" href="https://www.crypto101.io/">学习密码学的一套教程
CRYPTO101</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cryptography/" rel="tag"># cryptography</a>
              <a href="/tags/%E5%9B%BD%E4%BA%A7%E5%AF%86%E7%A0%81/" rel="tag"># 国产密码</a>
              <a href="/tags/ECDSA/" rel="tag"># ECDSA</a>
              <a href="/tags/SM/" rel="tag"># SM</a>
              <a href="/tags/RSA/" rel="tag"># RSA</a>
              <a href="/tags/AES/" rel="tag"># AES</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/08/06/sql%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/" rel="prev" title="sql注入入门">
                  <i class="fa fa-angle-left"></i> sql注入入门
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/08/07/format-strings/" rel="next" title="格式化字符串漏洞">
                  格式化字符串漏洞 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Max</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>
