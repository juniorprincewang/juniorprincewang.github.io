<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"juniorprincewang.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="由于自己要动手修改virtio源码，需要重新编写位于客户机前端virtio驱动，因此需要了解可加载内核模块（loadable kernel module, LKM）。在网上和书里面找了些资料，总结一下。">
<meta property="og:type" content="article">
<meta property="og:title" content="可加载内核模块编程">
<meta property="og:url" content="http://juniorprincewang.github.io/2018/03/22/loadable-kernel-module/index.html">
<meta property="og:site_name" content="TO DO">
<meta property="og:description" content="由于自己要动手修改virtio源码，需要重新编写位于客户机前端virtio驱动，因此需要了解可加载内核模块（loadable kernel module, LKM）。在网上和书里面找了些资料，总结一下。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-03-22T11:30:24.000Z">
<meta property="article:modified_time" content="2022-01-09T11:09:07.895Z">
<meta property="article:author" content="Max">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="LKM">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://juniorprincewang.github.io/2018/03/22/loadable-kernel-module/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://juniorprincewang.github.io/2018/03/22/loadable-kernel-module/","path":"2018/03/22/loadable-kernel-module/","title":"可加载内核模块编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>可加载内核模块编程 | TO DO</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TO DO</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">吾尝终日而思矣，不如须臾之所学也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">重要数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">文件结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inode%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">inode结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C"><span class="nav-number">2.</span> <span class="nav-text">字符设备注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">open函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#release%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">release函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readwrite%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">read&#x2F;write函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#llseek"><span class="nav-number">2.4.</span> <span class="nav-text">llseek</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ioctl"><span class="nav-number">2.5.</span> <span class="nav-text">ioctl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#printk"><span class="nav-number">3.1.</span> <span class="nav-text">printk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debugfs"><span class="nav-number">3.2.</span> <span class="nav-text">debugfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proc"><span class="nav-number">3.3.</span> <span class="nav-text">&#x2F;proc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E7%AB%9E%E4%BA%89"><span class="nav-number">4.</span> <span class="nav-text">并发和竞争</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.1.</span> <span class="nav-text">自旋锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">5.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kmalloc"><span class="nav-number">5.1.</span> <span class="nav-text">kmalloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">设备驱动程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">设备驱动程序模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sysfs"><span class="nav-number">7.1.</span> <span class="nav-text">sysfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kobject"><span class="nav-number">7.2.</span> <span class="nav-text">kobject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%8A%E5%B1%82%E5%AE%B9%E5%99%A8"><span class="nav-number">7.3.</span> <span class="nav-text">设备模型的上层容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">7.4.</span> <span class="nav-text">等待队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.5.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="nav-number">7.6.</span> <span class="nav-text">设备文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">重要函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ioctl-1"><span class="nav-number">8.1.</span> <span class="nav-text">ioctl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ioctl%E9%A1%BA%E5%BA%8F"><span class="nav-number">8.1.1.</span> <span class="nav-text">使用ioctl顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAioctl%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.2.</span> <span class="nav-text">创建ioctl命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E4%B8%AD%E7%9A%84ioctl%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.3.</span> <span class="nav-text">驱动中的ioctl命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84ioctl%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.4.</span> <span class="nav-text">创建用户空间的ioctl命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E8%B0%83%E7%94%A8ioctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">8.1.5.</span> <span class="nav-text">用户空间调用ioctl系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list_head"><span class="nav-number">8.2.</span> <span class="nav-text">list_head</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83-1"><span class="nav-number">8.2.1.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97work_queue"><span class="nav-number">8.3.</span> <span class="nav-text">工作队列work_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma"><span class="nav-number">8.4.</span> <span class="nav-text">dma</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number"></span> <span class="nav-text">参考资料</span></a></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Max</p>
  <div class="site-description" itemprop="description">文章本天成，妙手偶得之。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/juniorprincewang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;juniorprincewang" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:maxzywang@163.com" title="E-Mail → mailto:maxzywang@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://juniorprincewang.github.io/2018/03/22/loadable-kernel-module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TO DO">
      <meta itemprop="description" content="文章本天成，妙手偶得之。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="可加载内核模块编程 | TO DO">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          可加载内核模块编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-22 19:30:24" itemprop="dateCreated datePublished" datetime="2018-03-22T19:30:24+08:00">2018-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 19:09:07" itemprop="dateModified" datetime="2022-01-09T19:09:07+08:00">2022-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>由于自己要动手修改virtio源码，需要重新编写位于客户机前端virtio驱动，因此需要了解可加载内核模块（loadable
kernel module, LKM）。在网上和书里面找了些资料，总结一下。
<span id="more"></span></p>
<p>Linux众多优良特性之一就是可以在运行时扩展内核的功能。而每块可以在运行时添加到（删除）内核的代码称为一个模块。可加载的内核模块包括设备驱动程序。这样使内核可以在不知道硬件如何工作的情况下和硬件进行交互。每个模块由目标代码组成（没有连接成一个完整可执行文件），可以动态连接到运行中的内核中。</p>
<h2 id="重要数据结构">重要数据结构</h2>
<h3 id="文件操作">文件操作</h3>
<p><code>struct file_operations</code>结构或者其一个指针<code>fops</code>是可以将一个字符驱动连接到有编号得设备上。位于<a
target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L1730"><code>&lt;linux/fs.h&gt;</code></a>中。结构中得成员大部分负责系统调用实现。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations &#123;</span><br><span class="line">  struct module *owner;</span><br><span class="line">  loff_t (*llseek) (struct file *, loff_t, int);</span><br><span class="line">  ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">  ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line">  __poll_t (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">  long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">  long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">  int (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">  int (*open) (struct inode *, struct file *);</span><br><span class="line">  int (*flush) (struct file *, fl_owner_t id);</span><br><span class="line">  int (*release) (struct inode *, struct file *);</span><br><span class="line">  int (*lock) (struct file *, int, struct file_lock *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 一般的调用方式为: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations fops = &#123;</span><br><span class="line">  .owner = THIS_MODULE,</span><br><span class="line">  .llseek = llseek,</span><br><span class="line">  .open = open,</span><br><span class="line">  .read = read,</span><br><span class="line">  .release = release,</span><br><span class="line">  .write = write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这个声明使用标准的C<strong>标记式结构初始化</strong>语法，这个语法是内核首选的，因为它使驱动在结构定义的改变之间更加可移植,
并且,
标记式初始化允许结构成员重新排序；在某种情况下，通过安放经常使用的成员的指针在相同硬件高速存储行中，提高了性能。</p>
<h3 id="文件结构">文件结构</h3>
<p><code>struct file</code>或其指针<code>filp</code>定义于<code>&lt;linux/fs.h&gt;</code>中，位于内核结构，不出现在用户程序中。文件结构代表一个打开的文件（它不特指设备驱动），由内核在open时创建，并传递给文件操作的任何函数，直到最后关闭，内核释放这个数据结构。</p>
<p>成员函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *private_data;</span><br></pre></td></tr></table></figure> open 系统调用设置这个指针为 NULL,
在为驱动调用 open 方法之前。
你可自由使用这个成员或者忽略它；你可以使用这个成员来指向分配的数据，但是接着你必须记住在内核销毁文件结构之前，在
release 方法中释放那个内存。
private_data是一个有用的资源，在系统调用间保留状态信息，
我们大部分例子模块都使用它.</p>
<h3 id="inode结构">inode结构</h3>
<p><code>inode</code>结构由内核在内部用来表示文件，代表磁盘上的一个文件。<code>inode</code>不同于文件描述符的<code>struct file</code>文件结构，可能有代表单个文件的多个打开描述符的许多文件结构，但是它们都指向一个单个
inode 结构。</p>
<p>inode 结构包含大量关于文件的信息。作为一个通用的规则，这个结构只有 2
个成员对于编写驱动代码有用：
<code>dev_t i_rdev</code>：表示设备文件的节点，这个成员包含实际的设备号。
<code>struct cdev *i_cdev</code>：<code>struct cdev</code>是内核的内部结构，代表字符设备；这个成员包含一个指针，当节点指向是一个字符设备文件时，此域为指向这个inode结构的指针。</p>
<h2 id="字符设备注册">字符设备注册</h2>
<p>内核在内部使用类型<code>struct cdev</code>的结构体代表字符设备，位于<code>&lt;linux/cdev.h&gt;</code>中。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev &#123;   </span><br><span class="line">    struct kobject kobj;                  //内嵌的内核对象kobject</span><br><span class="line">    struct module *owner;                 //该字符设备所在的内核模块的对象指针</span><br><span class="line">    const struct file_operations *ops;    //指向设备驱动程序文件操作表的指针  </span><br><span class="line">    struct list_head list;                //用来将已经向内核注册的所有字符设备形成链表</span><br><span class="line">    dev_t dev;                            //字符设备的设备号，由主设备号和次设备号构成</span><br><span class="line">    unsigned int count;                   //隶属于同一主设备号的次设备号的个数</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>用下面的代码来初始化。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct cdev *my_cdev = cdev_alloc();</span><br><span class="line">my_cdev-&gt;ops = &amp;my_fops;</span><br></pre></td></tr></table></figure></p>
<p><code>cdev_init</code>将struct
cdev类型的结构体变量和file_operations结构体进行绑定。<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cdev_init(struct cdev *, const struct file_operations *);</span><br></pre></td></tr></table></figure></p>
<p><code>cdev_alloc()</code>函数的功能是动态地分配cdev描述符并初始化kobject数组结构，在引用计数器变0时会自动释放该描述符。<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct cdev *cdev_alloc(void);</span><br></pre></td></tr></table></figure></p>
<p><code>cdev_add()</code>函数功能是在设备驱动程序中注册一个cdev描述符。<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cdev_add(struct cdev *, dev_t, unsigned);</span><br></pre></td></tr></table></figure></p>
<p><code>cdev_del()</code>删除cdev对象。<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cdev_del(struct cdev *);</span><br></pre></td></tr></table></figure></p>
<p>新设备的驱动程序采用的分配方法为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int register_chrdev_region(dev_t from, unsigned count, const char *name)； </span><br><span class="line">//静态申请</span><br></pre></td></tr></table></figure> + from
:要分配的设备编号范围的初始值, 这组连续设备号的起始设备号,
相当于register_chrdev() 中主设备号。 + count:
连续编号范围，这组设备号的大小（也是次设备号的个数） + name:
编号相关联的设备名称. (/proc/devices); 本组设备的驱动名称</p>
<p>内核动态分配设备号： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)；</span><br></pre></td></tr></table></figure></p>
<ul>
<li>dev：这个函数的第一个参数，是输出型参数，获得一个分配到的设备号。可以用MAJOR宏和MINOR宏，将主设备号和次设备号，提取打印出来，看是自动分配的是多少，方便我们在mknod创建设备文件时用到主设备号和次设备号。
例如 mknod /dev/xxx c 主设备号 次设备号</li>
<li>baseminor：次设备号的基准，从第几个次设备号开始分配。</li>
<li>count：次设备号的个数。</li>
<li>name: 驱动的名字。</li>
<li>返回值：小于0，则错误，自动分配设备号错误。否则分配得到的设备号就被第一个参数带出来。</li>
</ul>
<p>上述两种方法可以为驱动程序分配任意范围的设备号。</p>
<p>字符设备经典的注册方法是： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);</span><br></pre></td></tr></table></figure>
这里<code>major</code>是感兴趣的主编号，<code>name</code>是驱动的名字（出现在<code>/proc/devices</code>），<code>fops</code>是缺省的<code>file_operations</code>结构。<br />
与注册配对的去除设备的方法是：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int unregister_chrdev(unsigned int major, const char *name);</span><br></pre></td></tr></table></figure> 从主次编号来建立 <code>dev_t</code>
数据项的宏定义。<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev_t MKDEV(unsigned int major, unsigned int minor);</span><br></pre></td></tr></table></figure></p>
<p><strong>sample code</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static struct cdev my_cdev[N_MINOR];    /* char device abstraction */</span><br><span class="line">static struct class *my_class;          /* linux device model */</span><br><span class="line">static int __init my_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    dev_t curr_dev;</span><br><span class="line">    dev_t dev_num;</span><br><span class="line"></span><br><span class="line">    /* obtain major */</span><br><span class="line">    dev_num = MKDEV(DRIVER_MAJOR, 0);</span><br><span class="line"></span><br><span class="line">    /* Request the kernel for N_MINOR devices */</span><br><span class="line">    alloc_chrdev_region(&amp;dev_num, 0, N_MINORS, &quot;my_driver&quot;);</span><br><span class="line"></span><br><span class="line">    /* Create a class : appears at /sys/class */</span><br><span class="line">    my_class = class_create(THIS_MODULE, &quot;my_driver_class&quot;);</span><br><span class="line"></span><br><span class="line">    /* Initialize and create each of the device(cdev) */</span><br><span class="line">    for (i = 0; i &lt; N_MINORS; i++) &#123;</span><br><span class="line"></span><br><span class="line">        /* Associate the cdev with a set of file_operations */</span><br><span class="line">        cdev_init(&amp;my_cdev[i], &amp;fops);</span><br><span class="line">        my_cdev[i].owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">        /* Build up the current device number. To be used further */</span><br><span class="line">        curr_dev = MKDEV(MAJOR(dev_num), MINOR(dev_num) + i);</span><br><span class="line"></span><br><span class="line">        /* Create a device node for this device. Look, the class is</span><br><span class="line">         * being used here. The same class is associated with N_MINOR</span><br><span class="line">         * devices. Once the function returns, device nodes will be</span><br><span class="line">         * created as /dev/my_dev0, /dev/my_dev1,... You can also view</span><br><span class="line">         * the devices under /sys/class/my_driver_class.</span><br><span class="line">         */</span><br><span class="line">        device_create(my_class, NULL, curr_dev, NULL, &quot;my_dev%d&quot;, i);</span><br><span class="line"></span><br><span class="line">        /* Now make the device live for the users to access */</span><br><span class="line">        cdev_add(&amp;my_cdev[i], curr_dev, 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="open函数">open函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*open)(struct inode *inode, struct file *filp);</span><br></pre></td></tr></table></figure>
<p>在大部分驱动中, open 应当 进行下面的工作:<br />
+ 检查设备特定的错误（例如设备没准备好, 或者类似的硬件错误）。 +
如果它第一次打开, 初始化设备。<br />
+ 如果需要, 更新 f_op 指针。<br />
+ 分配并填充要放进 filp-&gt;private_data 的任何数据结构。</p>
<h3 id="release函数">release函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*release)(struct inode *inode, struct file *filp)</span><br></pre></td></tr></table></figure>
<p>不是每个 <code>close</code> 系统调用引起调用 <code>release</code>
方法。 只有真正释放设备数据结 构的调用会调用这个方法。<br />
内核维持一个文件结构被使用多少次的计数。<br />
<code>fork</code> 和 <code>dup</code> 都不创建新文件(只有
<code>open</code> 这样); 它们只递增存在的结构中的计数。<br />
<code>close</code> 系统调用仅在文件结构计数掉到 <code>0</code> 时执行
<code>release</code> 方法， 这在结构被销毁时发生。<br />
<code>release</code> 方法和 <code>close</code>
系统调用之间的这种关系保证了驱动一次 <code>open</code> 只看到一次
<code>release</code> 。</p>
<h3 id="readwrite函数">read/write函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t *offp);</span><br><span class="line">ssize_t write(struct file *filp, const char __user *buff, size_t count, loff_t *offp);</span><br></pre></td></tr></table></figure>
<p>filp 是文件指针，count是请求的传输数据大小。<br />
buff 参数指向持有被写入数据的缓存，或者放入新数据的空缓存。<br />
最后，offp 是一个指针指向一个 <em>long offset type</em>
对象，它指出用户正在存取的文件位置。返回值是一个 <em>signed size
type</em>。</p>
<h3 id="llseek">llseek</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loff_t (*llseek) (struct file *, loff_t, int); </span><br></pre></td></tr></table></figure>
<p><code>llseek</code> 方法用作改变文件中的当前读/写位置,
并且新位置作为(正的)返回值。 <code>loff_t</code> 参数是一个
<code>long offset</code>, 并且就算在 32 位平台上也至少 64 位宽。
若发生错误，返回一个负值。 如果这个函数指针是 <code>NULL</code>,
<code>llseek</code> 调用会以潜在地无法预知的方式修改 file
结构中的位置计数器。</p>
<h3 id="ioctl">ioctl</h3>
<p>通过不同命令来对硬件进行控制。 函数原型： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br></pre></td></tr></table></figure> 用户空间的
<code>ioctl</code> 系统调用的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ioctl(int d, int request, ...);</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="http://www.linuxtcpipstack.com/820.html">大多数ioctl的实现都包含了一个switch语句来根据cmd参数选择对应的操作</a></p>
<p>下面函数可以在用户空间和内核空间拷贝数据。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long copy_to_user(void __user \*to,const void \*from, unsigned long count);</span><br><span class="line">unsigned long copy_from_user(void \*to, const void __user \*from, unsigned long count);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
位于<code>&lt;asm/uaccess.h&gt;</code>。至于实际的设备方法,
<code>read</code> 方法的任务是从设备拷贝数据到用户空间(使用
<code>copy_to_user</code>), 而 <code>write</code>
法必须从用户空间拷贝数据到设备(使用 <code>copy_from_user</code> )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_user(x, ptr)</span><br><span class="line">put_user(x, ptr)</span><br></pre></td></tr></table></figure>
<p><code>x</code>是内核空间的变量，<code>ptr</code>是用户空间的指针。上述两个函数主要用于内核空间和用户空间完成一些简单类型变量（char、int、long等）的拷贝任务，对于一些复合类型的变量，比如数据结构或者数组类型，<code>get_user</code>和<code>put_user</code>函数还是无法胜任，这两个函数内部将对指针指向的对象长度进行检查。</p>
<h2 id="调试">调试</h2>
<h3 id="printk">printk</h3>
<p><code>printk</code>
允许你根据消息的严重程度对其分类，通过附加不同的记录级别或者优先级在消息上。常常用一个宏定义来指示记录级别。
比如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_INFO &quot;Hello!\n&quot;);</span><br></pre></td></tr></table></figure> 记录宏定义扩展成一个字串,
在编译时与消息文本连接在一起;这就是为什么下面的在优先级和格式串之间没有逗号的原因。
有8种可能的记录等级。在<code>&lt;linux/kernel.h&gt;</code>里定义。按照严重等级递减顺序依次是：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KERN_EMERG</span><br><span class="line">	用于紧急消息, 常常是那些崩溃前的消息.</span><br><span class="line">KERN_ALERT</span><br><span class="line">	需要立刻动作的情形.</span><br><span class="line">KERN_CRIT</span><br><span class="line">	严重情况, 常常与严重的硬件或者软件失效有关.</span><br><span class="line">KERN_ERR</span><br><span class="line">	用来报告错误情况; 设备驱动常常使用 KERN_ERR 来报告硬件故障.</span><br><span class="line">KERN_WARNING</span><br><span class="line">	有问题的情况的警告, 这些情况自己不会引起系统的严重问题.</span><br><span class="line">KERN_NOTICE</span><br><span class="line">	正常情况, 但是仍然值得注意. 在这个级别一些安全相关的情况会报告.</span><br><span class="line">KERN_INFO</span><br><span class="line">	信息型消息。在这个级别, 很多驱动在启动时打印它们发现的硬件的信息.</span><br><span class="line">KERN_DEBUG</span><br><span class="line">	用作调试消息。</span><br></pre></td></tr></table></figure></p>
<p>整数范围0~7，越小表示优先级越高。这里面读取的方式有所不同。基于记录级别，内核可能打印消息到当前控制台，可能是一个文本模式终端，串口，或者是一台并口打印机，如果优先级小于整型值
console_loglevel，消息被递交给控制台，一次一行（除非提供一个新行结尾，否则什么都不发送）。
如果klogd 和 syslogd 都在系统中运行， 内核消息被追加到 /var/log/messages
（或者另外根据你的 syslogd 配置处理），独立于 console_loglevel，如果
klogd 没有运行，你只有读 /proc/kmsg （用<code>dmsg</code> 命令最易做到
）将消息取到用户空间。 当使用 klogd
时，你应当记住，它不会保存连续的同样的行；它只保留第一个这样的行，随后是，它收到的重复行数。
也可以通过文本文件 <code>/proc/sys/kernel/printk</code>
读写控制台记录级别。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/kernel/printk</span><br><span class="line">4	4	1	7</span><br></pre></td></tr></table></figure> 这个文件有 4 个整型值:
当前记录级别4，适用没有明确记录级别的消息的缺省级别4，允许的最小记录级别1，以及启动时缺省记录级别7。</p>
<h3 id="debugfs">debugfs</h3>
<p><code>debugfs</code>是一种用于内核调试的虚拟文件系统，内核开发者通过debugfs和用户空间交换数据。</p>
<p>默认情况下，debugfs会被挂载在目录<code>/sys/kernel/debug</code>
之下，如果发行版里没有自动挂载，可以用如下命令手动完成。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs none /your/debugfs/dir</span><br></pre></td></tr></table></figure></p>
<p>创建和撤销目录及文件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct dentry *debugfs_create_dir(const char *name, struct dentry *parent);</span><br><span class="line">struct dentry *debugfs_create_file(const char *name, mode_t mode, </span><br><span class="line">        struct dentry *parent, void *data, </span><br><span class="line">        const struct file_operations *fops);</span><br><span class="line">void debugfs_remove(struct dentry *dentry);</span><br><span class="line">void debugfs_remove_recursive(struct dentry *dentry);</span><br></pre></td></tr></table></figure>
还可以创建单个文件以及BLOB文件。</p>
<h3 id="proc">/proc</h3>
<p><code>/proc</code>
是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。
大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">https://elixir.bootlin.com/linux/v3.7/source/include/linux/proc_fs.h#L152</span><br><span class="line"></span><br><span class="line">struct proc_dir_entry *proc_mkdir(const char *name,</span><br><span class="line">                                  struct proc_dir_entry *parent) </span><br><span class="line"></span><br><span class="line">struct proc_dir_entry *proc_create(const char *name, </span><br><span class="line">                                    umode_t mode, </span><br><span class="line">                                    struct proc_dir_entry *parent, </span><br><span class="line">                                    const struct file_operations *proc_fops);</span><br><span class="line"></span><br><span class="line">struct proc_dir_entry *proc_create_data(const char *, umode_t,</span><br><span class="line">                                         struct proc_dir_entry *,</span><br><span class="line">                                         const struct file_operations *,</span><br><span class="line">                                         void *);</span><br><span class="line">void proc_remove(struct proc_dir_entry *);</span><br><span class="line"></span><br><span class="line">void remove_proc_entry(const char *, struct proc_dir_entry *);</span><br></pre></td></tr></table></figure>
<h2 id="并发和竞争">并发和竞争</h2>
<h3 id="自旋锁">自旋锁</h3>
<p>作为互斥锁，自旋锁只有两个值：上锁和解锁。如果锁是可用的，上锁位被置为并且代码进入临界区；相反，如果这个锁已被获得，代码进入一个紧凑的循环中反复检查这个锁，直到变得可用。</p>
<p>自旋锁原语在<code>&lt;linux/spinlock.h&gt;</code>中。一个实际的锁有类型
<code>spinlock_t</code>。象任何其他数据结构，一个自旋锁必须初始化。
这个初始化可以在编译时完成<code>spinlock_t my_lock = SPIN_LOCK_UNLOCKED;</code>或运行时使用<code>void spin_lock_init(spinlock_t *lock);</code>。</p>
<p>在进入临界区钱，必须获得<code>lock</code>：
<code>void spin_lock(spinlock_t *lock);</code></p>
<p>在获得自旋锁之前，禁止中断(只在本地处理器)；之前的中断状态保存在
<code>flags</code> 里:
<code>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);</code></p>
<p>获取锁之前禁止软件中断，但是硬件中断留作打开的：
<code>void spin_lock_bh(spinlock_t *lock);</code></p>
<p>当禁止本地中断时可以使用:
<code>void spin_lock_irq(spinlock_t *lock);</code></p>
<p>为释放一个已获得的锁，传递它给: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void spin_unlock(spinlock_t *lock);</span><br><span class="line">void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);</span><br><span class="line">void spin_unlock_irq(spinlock_t *lock);</span><br><span class="line">void spin_unlock_bh(spinlock_t *lock);</span><br></pre></td></tr></table></figure> 每个 spin_unlock
变体恢复由对应的 spin_lock 函数锁做的工作。传递给spin_unlock_irqrestore
的 flags 参数必须是传递给 spin_lock_irqsave 的同一个变量。你必须也调用
spin_lock_irqsave 和 spin_unlock_irqrestore 在同一个函数里。</p>
<h2 id="内存分配">内存分配</h2>
<p>内核通过<code>kmalloc</code>和<code>kfree</code>来分配和释放内存，位于<code>&lt;linux/slab.h&gt;</code>。</p>
<h3 id="kmalloc">kmalloc</h3>
<p>这个函数快（除非它阻塞）并且不清零它获得的内存；分配的区仍然持有它原来的内容，分配的区也是在物理内存中连续。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *kmalloc(size_t size, int flags);</span><br></pre></td></tr></table></figure>
<p>第1个参数是要分配的块的大小；第2个参数，分配标志位于
<code>&lt;linux/gfp.h&gt;</code>，以几个方式控制<code>kmalloc</code>的行为，内部最终通过调用
<code>__get_free_pages</code> 来进行，它是 <code>GFP_</code>
前缀的来源。</p>
<ul>
<li>GFP_KERNEL</li>
</ul>
<p><code>GFP_KERNEL</code> 代表运行在内核空间的进程而进行的。 使用
GFP_KENRL意味着 kmalloc
能够使当前进程在少内存的情况下睡眠来等待一页。</p>
<ul>
<li>GFP_ATOMIC</li>
</ul>
<p>用在中断处理和进程上下文之外的其他代码中分配内存，进程从不睡眠等待。</p>
<ul>
<li>GFP_USER</li>
</ul>
<p>用来为用户空间页来分配内存，它可能睡眠。</p>
<ul>
<li>__GFP_DMA</li>
</ul>
<p>这个标志要求分配在能够 DMA 的内存区，跟平台相关。</p>
<ul>
<li>__GFP_HIGHMEM</li>
</ul>
<p>这个标志指示分配的内存可以位于高端内存，跟平台相关。</p>
<h2 id="设备驱动程序">设备驱动程序</h2>
<h2 id="设备驱动程序模型">设备驱动程序模型</h2>
<p>Linux设备模型提取了设备操作的共同属性，进行抽象，并将这部分共同的属性在内核中实现，而为需要新添加设备或驱动提供一般性的统一接口，这个框架称为设备驱动程序模型。</p>
<p>Linux设备模型学习分为：Linux设备底层模型，描述设备的底层层次实现（kobject）；Linux上层容器，包括总线类型（bus_type）、设备（device）和驱动（device_driver）。</p>
<h3 id="sysfs">sysfs</h3>
<p><code>sysfs</code>是Linux一种特殊的文件系统，允许
<strong>用户态</strong>应用程序访问内核内部数据结构，并提供了内核数据结构的附加信息。
sysfs<code>文件系统的主要目的是展现设备驱动程序模型组件间的层次关系。</code>sysfs<code>被安装于</code>/sys<code>目录。</code>/sys`目录描述了设备驱动模型的层次关系。
主要包括：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>设备</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>block</td>
<td>所有块设备</td>
</tr>
<tr class="even">
<td>devices</td>
<td>系统所有设备（块设备特殊），对应struct device的层次结构</td>
</tr>
<tr class="odd">
<td>bus</td>
<td>系统中所有总线类型（指总线类型而不是总线设备，总线设备在devices下），bus的每个子目录都包含
<br/> --devices：包含到devices目录中设备的软链接
<br/>--drivers：与bus类型匹配的驱动程序 <br/></td>
</tr>
<tr class="even">
<td>class</td>
<td>系统中设备类型（如声卡、网卡、显卡等）</td>
</tr>
<tr class="odd">
<td>fs</td>
<td>一些文件系统，具体可参考filesystems /fuse.txt中例子</td>
</tr>
<tr class="even">
<td>dev</td>
<td>包含2个子目录<br>--char：字符设备链接，链接到devices目录，以<major>:<minor>命名<br>--block：块设备链接</td>
</tr>
</tbody>
</table>
<h3 id="kobject">kobject</h3>
<p><code>kojbect</code>是设备驱动程序模型的核心数据结构，每个kobject对应于sysfs文件系统中的一个目录，它的功能是提供引用计数和维持父子（parent）结构、平级（sibling）目录关系，许多kobject结构就构成了层次结构。</p>
<p><code>kset</code>:
它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个
kboject 实现，因而它同时也是一个 kobject (面向对象 OOP
概念中的继承关系。</p>
<h3 id="设备模型的上层容器">设备模型的上层容器</h3>
<p>上层容器包括总线类型（bus_type）、设备（device）和驱动（device_driver）。</p>
<p>每一种总线类型由<code>struct bus_type</code>对象描述。
<code>bus_type</code> 通过扫描 <em>设备链表</em>和
<em>驱动链表</em>，使用
<code>match</code>方法查找匹配的设备和驱动，然后将
<code>struct device</code> 中的 <code>driver</code> 设置为匹配的驱动，将
<code>struct device_driver</code> 中的 <code>device</code>
设置为匹配的设备，这就完成了将 <strong>总线</strong> 、
<strong>设备</strong> 和 <strong>驱动</strong> 3者之间的关联。</p>
<p>每个设备由一个<code>struct device</code>对象来描述。</p>
<p>内核提供了<code>device_create</code>函数在<code>sysfs</code>创建和注册
<strong>设备</strong>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct device *device_create( struct class *class, </span><br><span class="line">                              struct device *parent,</span><br><span class="line">                              dev_t devt, </span><br><span class="line">                              void *drvdata, </span><br><span class="line">                              const char *fmt, </span><br><span class="line">                              ...)</span><br><span class="line">- class：设备要注册到的struct class对象</span><br><span class="line">- parent：新设备的父设备，如果没有就指定为NULL</span><br><span class="line">- devt：主从设备号</span><br><span class="line">- drvdata：在回调时添加到设备中的数据</span><br><span class="line">- fmt：设备名字</span><br></pre></td></tr></table></figure> 相应的设备移除函数是
<code>device_destory</code>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void device_destroy ( struct class *    class,</span><br><span class="line">                      dev_t   devt);</span><br></pre></td></tr></table></figure></p>
<p>每个驱动程序由<code>struct device_driver</code>对象描述。</p>
<p>每个类由一个<code>struct class</code>对象描述。所有的类对象都属于与<code>/sys/class</code>目录相对应的<code>class_subsys</code>子系统。同一类中的设备驱动程序可以对用户态应用程序提供相同的功能。</p>
<p>内核提供了<code>create_class</code>函数来创建一个类对象，这个类存在于
<code>sysfs</code>
下面，<code>class_destroy</code>函数来注销一个类对象。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct class * class_create ( struct module *   owner,</span><br><span class="line">  const char *    name);</span><br><span class="line"></span><br></pre></td></tr></table></figure> +
owner: 指针，指向了拥有此 struct class 的模块。 + name：
指针，指向了此类的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void class_destroy (  struct class *    cls);</span><br></pre></td></tr></table></figure>
<ul>
<li>cls: 指针，指向了要销毁的struct class 对象。</li>
</ul>
<p>一旦创建好了这个类，再调用 <code>device_create()</code>
函数来在/dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应
<code>device_create()</code>函数，去 <code>/sys</code>
下寻找对应的类从而创建设备节点。</p>
<h3 id="等待队列">等待队列</h3>
<h3 id="参考">参考</h3>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/xiahouzuoxin/article/details/8943863">Linux设备驱动模型</a></p>
<h3 id="设备文件">设备文件</h3>
<p>设备文件分为字符设备文件和块设备文件。差异为： -
块设备的数据可以被随机访问，典型的例子是硬盘、CD-ROM驱动器。 -
字符设备的数据或者不可以被随机访问，或者可以被随机访问，但是访问随机数据所需要的时间很大程度上依赖于数据在设备间的位置。</p>
<p>设备标识符由设备文件的类型（字符或块）和一对参数组成。第一个参数称为主设备号（major
number），它标识了设备的类型。具有相同主设备号和类型的所有设备文件共享相同的文件操作集合，因为它们由同一个设备驱动程序处理的。第二个参数称为次设备号（minor
number），它标识了主设备号相同的设备组中的一个特定设备。例如，由相同的磁盘控制器管理的一组磁盘具有相同的主设备号和不同的次设备号。</p>
<p><code>mknod</code>系统调用用来创建设备文件，参数包括设备文件名、设备类型、主设备号及次设备号。设备文件通常包含在<code>/dev</code>目录中。主设备号对应的宏位于<code>include/linux/major.h</code>中。</p>
<p>为了解决设备号分配不足问题，Linux
2.6增加了设备号的编码大小，由原来的8位的次设备号改为20位的次设备号，主设备号的编码为12位。通常把这两个参数合并成一个32位的dev_t变量；<code>MAJOR</code>和<code>MINOR</code>宏可以从<code>dev_t</code>中提取出主设备号和次设备号，而<code>MKDEV</code>宏可以把主设备号和次设备号合并成一个<code>dev_t</code>值。定义为<code>typedef u_long dev_t;</code></p>
<p>对于分配设备号和创建设备文件，静态的方法容易产生冲突并且移植性不好，因此如今更倾向于动态处理。</p>
<h2 id="重要函数">重要函数</h2>
<h3 id="ioctl-1">ioctl</h3>
<p>通常用户态程序访问内核态资源要通过系统调用实现，传统的操作系统通常用这种方式给用户空间提供了上百个系统调用。因为大多数硬件设备只能够在内核空间内直接寻址,但是当访问非标准硬件设备这些系统调用显得不合适,有时候用户模式可能需要直接访问设备，比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</p>
<p>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个<code>ioctl</code>接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的<code>ioctl</code>调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p>
<p><code>ioctl</code>（input/output
control）是一个专用于设备输入输出操作的系统调用，该调用传入一个跟设备有关的请求码，系统调用的功能完全取决于请求码。</p>
<h4 id="使用ioctl顺序">使用ioctl顺序</h4>
<ul>
<li>在驱动中创建ioctl命令</li>
<li>在驱动中写ioctl函数</li>
<li>在用户态程序创建ioctl命令</li>
<li>在用户态程序使用ioctl命令</li>
</ul>
<h4 id="创建ioctl命令">创建ioctl命令</h4>
<p>32位的命令数字由4部分组成： + The Magic
Number，魔数，是唯一得数字或字符，8 位宽(_IOC_TYPEBITS)。 + Command
Number ，序(顺序)号. 它是 8 位(_IOC_NRBITS)宽. r. + Argument type
，参数类型，14 位。 + Direction of data
transfer，数据传送的方向，2位。_IOC_NONE(没有数据传输), _IOC_READ,
_IOC_WRITE, 和 _IOC_READ|_IOC_WRITE (数据在 2 个方 向被传送)。</p>
<p>但是在创建ioctl命令时，使用宏定义生成。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define &quot;ioctl_command&quot; _IOX(&quot;magic number&quot;,&quot;command number&quot;,&quot;argument type&quot;)</span><br></pre></td></tr></table></figure>
<code>_IOX</code> 可以取值: + <code>_IO</code>:
_IO(type,nr)，给没有参数的命令。 + <code>_IOW</code>:
_IOW(type,nr,datatype)，给写数据 (copy_from_user) + <code>_IOR</code>:
_IOR(type, nre, datatype)，给从驱动中读数据的(copy_to_user) +
<code>_IOWR</code>: _IOWR(type,nr,datatype)，给双向传送。</p>
<p>头文件中定义的宏, 可在驱动中来解码这个宏: _IOC_DIR(nr),
_IOC_TYPE(nr), _IOC_NR(nr), 和 _IOC_SIZE(nr) 。</p>
<p>比如字体驱动程序的IOCTL调用命令 SETFONT。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PRIN_MAGIC &#x27;S&#x27;</span><br><span class="line">#define SEQ_NO 1</span><br><span class="line">#define SETFONT __IOW(PRIN_MAGIC, SEQ_NO, unsigned long)</span><br></pre></td></tr></table></figure>
在用户态调用方式为 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *font = &quot;Arial&quot;;</span><br><span class="line">ret_val = ioctl(fd, SETFONT, font); </span><br></pre></td></tr></table></figure>
<code>font</code>是一个指针，它是一个被表示成 <code>unsigned long</code>
的地址，<code>_IOW</code> 表示只写数据，</p>
<h4 id="驱动中的ioctl命令">驱动中的ioctl命令</h4>
<p>定义完IOCTL命令后，下一步就是要在驱动中完成ioctl函数。函数定义如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">long etx_ioctl(struct file *f, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    switch(cmd) &#123;</span><br><span class="line">        case WR_VALUE:</span><br><span class="line">            copy_from_user(&amp;value ,(int32_t*) arg, sizeof(value));</span><br><span class="line">            printk(KERN_INFO &quot;Value = %d\n&quot;, value);</span><br><span class="line">            break;</span><br><span class="line">        case RD_VALUE:</span><br><span class="line">            copy_to_user((int32_t*) arg, &amp;value, sizeof(value));</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static struct file_operations fops =</span><br><span class="line">&#123;</span><br><span class="line">  .owner = THIS_MODULE,</span><br><span class="line">  .unlocked_ioctl = etx_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ioctl函数参数 + <code>file</code> :
文件指针，指向了应用程序传递的文件。 + <code>cmd</code> :
从用户空间调用的ioctl命令。 + <code>arg</code> :
用户空间传递的参数。</p>
<p>对于响应一个无效的 ioctl 命令，返回
<code>-ENIVAL("Invalid argument")</code> 。</p>
<h4 id="创建用户空间的ioctl命令">创建用户空间的ioctl命令</h4>
<p>用户空间的ioctl命令和内核空间的ioctl命令一样，因此这些命令和参数需要在内核态和用户态间共享，一般放在各自的头文件中。</p>
<h4 id="用户空间调用ioctl系统调用">用户空间调用ioctl系统调用</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">int ioctl(int fd, unsigned long request, ...);</span><br></pre></td></tr></table></figure>
<p><code>fd</code>是打开的文件描述符，<code>request</code>是用户程序对设备的控制命令码，后面省略号表示命令补充参数，如果存在第三个参数，那它是一个指针<code>void *</code>
类型。</p>
<p>成功返回0或者正数，出错返回-1，<code>errno</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ERRORS：</span><br><span class="line">       EBADF  fd is not a valid descriptor.</span><br><span class="line"></span><br><span class="line">       EFAULT argp references an inaccessible memory area.</span><br><span class="line"></span><br><span class="line">       EINVAL request or argp is not valid.</span><br><span class="line"></span><br><span class="line">       ENOTTY fd is not associated with a character special device.</span><br><span class="line"></span><br><span class="line">       ENOTTY The specified request does not apply to the kind of object that the descriptor fd references.</span><br></pre></td></tr></table></figure>
<p>比如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int number=2;</span><br><span class="line">ioctl(fd, WR_VALUE, (int32_t*) &amp;number); </span><br></pre></td></tr></table></figure></p>
<p><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15807846/ioctl-linux-device-driver">IOCTL
Linux device driver</a> <a
target="_blank" rel="noopener" href="https://opensourceforu.com/2011/08/io-control-in-linux/">Device
Drivers, Part 9: I/O Control in Linux</a> <a
target="_blank" rel="noopener" href="https://embetronicx.com/tutorials/linux/device-drivers/ioctl-tutorial-in-linux/">Linux
Device Driver Tutorial Part 8 – I/O Control in Linux IOCTL()</a>
内核模块<a
target="_blank" rel="noopener" href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/6788a577c394a2fc512d8f3df0806d84dc09f355/kernel_module/ioctl.c">ioctl.c</a>和<a
target="_blank" rel="noopener" href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/6788a577c394a2fc512d8f3df0806d84dc09f355/kernel_module/ioctl.h">ioctl.h</a>还有用<a
target="_blank" rel="noopener" href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/6788a577c394a2fc512d8f3df0806d84dc09f355/kernel_module/user/ioctl.c">户态应用程序ioctl.c</a>与<a
target="_blank" rel="noopener" href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/6788a577c394a2fc512d8f3df0806d84dc09f355/rootfs_overlay/ioctl.sh">调用脚本</a></p>
<h3 id="list_head">list_head</h3>
<p>Linux的列表<code>list_head</code>位于<code>include/linux/types.h</code>。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct list_head &#123;</span><br><span class="line">    struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>struct list_head</code>是双向链表。在Linux内核链表中，需要用链表组织起来的数据通常会包含一个struct
list_head成员。 常用操作为：</p>
<ul>
<li><p>声明和初始化 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br><span class="line">#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span><br><span class="line"></span><br><span class="line">#define INIT_LIST_HEAD(ptr) do &#123; \</span><br><span class="line">    (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure></p></li>
<li><p>插入</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在表头插入</span><br><span class="line">static inline void list_add(struct list_head *new, struct list_head *head);</span><br><span class="line">// 在表尾插入</span><br><span class="line">static inline void list_add_tail(struct list_head *new, struct list_head *head);</span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_del(struct list_head *entry);</span><br></pre></td></tr></table></figure>
<ul>
<li>迁移</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_move(struct list_head *list, struct list_head *head);</span><br><span class="line">static inline void list_move_tail(struct list_head *list, struct list_head *head);</span><br></pre></td></tr></table></figure>
<ul>
<li>合并</li>
</ul>
<p>整个列表合并 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_splice(struct list_head *list, struct list_head *head);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>遍历</li>
</ul>
<p>通过这个list_head成员访问到作为它的所有者的节点数据。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(nf_sockopts-&gt;next, struct nf_sockopt_ops, list);</span><br></pre></td></tr></table></figure></p>
<p>这里有两个宏，<code>list_for_each</code>的<code>pos</code>是<code>(struct list_head \*)</code>，而<code>list_for_each_entry</code>的<code>pos</code>是数据项结构指针类型。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define list_for_each(pos, head) \</span><br><span class="line">	for (pos = (head)-&gt;next, prefetch(pos-&gt;next); pos != (head); \</span><br><span class="line">        pos = pos-&gt;next, prefetch(pos-&gt;next))</span><br><span class="line">#define list_for_each_entry(pos, head, member)</span><br></pre></td></tr></table></figure></p>
<h4 id="参考-1">参考</h4>
<p><a
target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/kernel/l-chain/">深入分析
Linux 内核链表</a></p>
<h3 id="工作队列work_queue">工作队列work_queue</h3>
<p>创建一个名为<code>my_work</code>的结构体变量。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct work_struct my_work; </span><br></pre></td></tr></table></figure>
初始化已经创建的my_work，其实就是往这个结构体变量中添加处理函数的入口地址和data的地址，通常在驱动的open函数中完成
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;my_work,my_func,&amp;data); </span><br></pre></td></tr></table></figure></p>
<p>将工作结构体变量添加入系统的共享工作队列，添加入队列的工作完成后会自动从队列中删除。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_work(&amp;my_work); </span><br></pre></td></tr></table></figure></p>
<h3 id="dma">dma</h3>
<p>初始化散列表项目。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void sg_init_one(struct scatterlist *sg, const void *buf, unsigned int buflen)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>sg</code>：散列表</li>
<li><code>buf</code>：IO的虚拟地址</li>
<li><code>buflen</code>：IO长度</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<p>[1] 深入理解Linux内核 [2] Linux设备驱动程序 [3] <a
target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/linux-kernel-module-part01">编写Linux内核模块——第一部分：前言</a>
[4] <a
target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/linux-kernel-module-part02">编写Linux内核模块——第二部分：字符设备</a>
[5] <a
target="_blank" rel="noopener" href="https://blog.csdn.net/ixidof/article/details/7893680">标记化结构初始化语法---结构体成员前加小数点</a>
[6] <a
target="_blank" rel="noopener" href="https://www.binss.me/blog/sysfs-udev-and-Linux-Unified-Device-Model/">sysfs、udev
和 它们背后的 Linux 统一设备模型</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kernel/" rel="tag"># kernel</a>
              <a href="/tags/LKM/" rel="tag"># LKM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/03/01/%E8%A7%A3%E5%86%B3su-Authentication-failure/" rel="prev" title="解决su: Authentication failure">
                  <i class="fa fa-angle-left"></i> 解决su: Authentication failure
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/04/03/centos%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8/" rel="next" title="centos启动加载驱动">
                  centos启动加载驱动 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Max</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>
